<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>Hello World</title>
    <url>/2021/10/15/hello-world/</url>
    <content><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p>
<span id="more"></span>

<h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo new <span class="string">&quot;My New Post&quot;</span></span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p>
<h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p>
<h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p>
<h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>
]]></content>
      <tags>
        <tag>hexo</tag>
      </tags>
  </entry>
  <entry>
    <title>前端vue.js框架学习心得</title>
    <url>/2021/10/16/%E5%89%8D%E7%AB%AFvue-js%E6%A1%86%E6%9E%B6%E5%AD%A6%E4%B9%A0%E5%BF%83%E5%BE%97/</url>
    <content><![CDATA[<h2 id="Vue-复习"><a href="#Vue-复习" class="headerlink" title="Vue 复习"></a>Vue 复习</h2><h4 id="1-计算属性computed"><a href="#1-计算属性computed" class="headerlink" title="1.计算属性computed"></a>1.计算属性computed</h4><ul>
<li>计算属性，是一种定义在computed里面的属性，其中有set和get方法，但是set一般都不使用，所以我们一般都不写，然后get属性，我们为了方便的话都使用，都是把get直接换成变量名的形式。<strong>所以我们在通过must语法定义值的时候都不会带括号</strong></li>
</ul>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">computed：&#123;</span><br><span class="line">	<span class="attr">fullName</span>:&#123;</span><br><span class="line">		<span class="attr">set</span>:<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">			#set 一般都不使用，省略</span><br><span class="line">		&#125;,</span><br><span class="line">		<span class="attr">get</span>:<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">			#而get我们一般都省略</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<span id="more"></span>

<p>省略之后变成这种方式，所以fullName 是计算属性。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">computed:&#123;</span><br><span class="line">	<span class="attr">fullName</span>:<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">		</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><strong>计算属性computed，比methods方法要好，因为computed方法有缓存，多次使用只会调用一次，而methods每一次使用都会重新调用。</strong></li>
</ul>
<h4 id="2-Watch属性"><a href="#2-Watch属性" class="headerlink" title="2.Watch属性"></a>2.Watch属性</h4><ul>
<li>通过Watch 可以动态带检测到data里面的属性变化，当属性变化时就会调用watch属性里面的方法。但是方法的名字要与被检测的data变量一致。</li>
</ul>
<h4 id="3-编译作用域"><a href="#3-编译作用域" class="headerlink" title="3.编译作用域"></a>3.编译作用域</h4><ul>
<li>编译作用域就是在模板里面使用变量的时候，会首先看是这个模板在谁的组件下，去当前模板的组件下去找到该变量。</li>
</ul>
<h4 id="4-作用域插槽"><a href="#4-作用域插槽" class="headerlink" title="4.作用域插槽"></a>4.作用域插槽</h4><ul>
<li><p>作用域插槽就是父组件对要展示的子组件的格式不满意，要拿到它的数据进行修改。</p>
<ul>
<li>这就涉及1点：<ul>
<li>父组件无法直接拿到子组件的变量。</li>
</ul>
</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">#这个是父组件模板</span><br><span class="line">&lt;div id=<span class="string">&quot;app&quot;</span>&gt;</span><br><span class="line"><span class="xml"><span class="tag">&lt;<span class="name">cpn</span>&gt;</span></span></span><br><span class="line"><span class="xml">#vue2.5x必须通过<span class="tag">&lt;<span class="name">template</span>&gt;</span>的方式获取子组件里的属性。而slot-scope 则是获取子组件里面的slot</span></span><br><span class="line"><span class="xml"><span class="tag">&lt;<span class="name">template</span> <span class="attr">slot-scope</span> = <span class="string">&quot;slot&quot;</span>&gt;</span></span></span><br><span class="line"><span class="xml">	#通过slot.data拿到数据，进行处理</span></span><br><span class="line"><span class="xml">	<span class="tag">&lt;<span class="name">span</span>&gt;</span>&#123;&#123;slot.data.join(&#x27; - &#x27;)&#125;&#125;<span class="tag">&lt;/<span class="name">span</span>&gt;</span></span></span><br><span class="line"><span class="xml"><span class="tag">&lt;/<span class="name">template</span>&gt;</span></span></span><br><span class="line"><span class="xml"><span class="tag">&lt;/<span class="name">cpn</span>&gt;</span></span></span><br><span class="line"><span class="xml"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">#这个是子组件</span><br><span class="line">&lt;template id=<span class="string">&quot;cpn&quot;</span>&gt;</span><br><span class="line">	<span class="xml"><span class="tag">&lt;<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="xml">		<span class="tag">&lt;<span class="name">slot</span> <span class="attr">:data</span>=<span class="string">&quot;planguages&quot;</span>&gt;</span></span></span><br><span class="line"><span class="xml">			#slot 里面的内容为默认内容，父组件里面可以进行替换</span></span><br><span class="line"><span class="xml">			<span class="tag">&lt;<span class="name">ul</span>&gt;</span></span></span><br><span class="line"><span class="xml">				<span class="tag">&lt;<span class="name">li</span> <span class="attr">v-for</span>=<span class="string">&quot;item in planguages&quot;</span>&gt;</span>&#123;&#123;item&#125;&#125;<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span></span><br><span class="line"><span class="xml">			<span class="tag">&lt;/<span class="name">ul</span>&gt;</span></span></span><br><span class="line"><span class="xml">		<span class="tag">&lt;/<span class="name">slot</span>&gt;</span></span></span><br><span class="line"><span class="xml">	<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">&lt;/template&gt;</span><br><span class="line"><span class="xml"><span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">&quot;../js/vue.js&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span></span><br><span class="line"><span class="keyword">new</span> vue(&#123;</span><br><span class="line">	<span class="attr">el</span>:<span class="string">&#x27;#app&#x27;</span>,</span><br><span class="line">	<span class="attr">components</span>:&#123;</span><br><span class="line">	<span class="attr">cpn</span>:&#123;</span><br><span class="line">		<span class="attr">template</span>:<span class="string">&#x27;#cpn&#x27;</span>,</span><br><span class="line">		<span class="function"><span class="title">data</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">			<span class="keyword">return</span> &#123;</span><br><span class="line">			#这个是子组件里的变量，父组件无法获取</span><br><span class="line">				<span class="attr">planguages</span>:[<span class="string">&#x27;JavaScript&#x27;</span>,<span class="string">&#x27;C++&#x27;</span>,<span class="string">&#x27;Java&#x27;</span>,<span class="string">&#x27;C#&#x27;</span>,<span class="string">&#x27;Python&#x27;</span>,<span class="string">&#x27;Go&#x27;</span>,<span class="string">&#x27;Swift&#x27;</span>]</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></li>
</ul>
<h4 id="5-Webpack"><a href="#5-Webpack" class="headerlink" title="5.Webpack"></a>5.Webpack</h4><ul>
<li>webpack 的作用就是可以模块化，和打包<ul>
<li>模块化<ul>
<li>在ES6之前，我们要进行模块化开发，就必须借助于其他的工具，让我们可以进行模块化开发。</li>
<li>并且在通过模块化开发完成了项目后，还需要处理模块间的各种依赖，并且将其进行整合打包。</li>
<li>而webpack其中的一个核心就是让我们可能进行模块化开发，并且会帮助我们处理模块间的依赖问题（就是文件之间的导入导出）。</li>
<li>而且不仅仅是js文件，我们的css、图片、json文件等等，在webpack中都可以当做模块来使用</li>
</ul>
</li>
<li>打包<ul>
<li>就是将webpa中的各种资源模块进行打包合并成一个或多个包。</li>
<li>并且在打包的过程中，还可以对资源进行处理，比如压缩图片，将scss转成css，将ES6语法转成ES5语法，将TypeScript转换成Js等等操作。</li>
</ul>
</li>
</ul>
</li>
</ul>
<h5 id="5-1-具体原因和过程"><a href="#5-1-具体原因和过程" class="headerlink" title="5.1 具体原因和过程"></a>5.1 具体原因和过程</h5><p>因为我们写的代码可能包含，ES6，less,等的一些代码，我们需要把我们的代码上传到服务器之后然后，浏览器从服务器请求数据，这个时候这些代码浏览器是识别不了的，这个时候必须使用webpac进行转换。</p>
<h5 id="5-2-webpack的使用"><a href="#5-2-webpack的使用" class="headerlink" title="5.2 webpack的使用"></a>5.2 webpack的使用</h5><ul>
<li><p>webpack的使用依赖于node的环境，node有一个包管理工具叫做npm。webpack在项目中是开发时依赖。（因为运行的时候不需要，只需要用它打包）</p>
</li>
<li><p><strong>–save -dev</strong></p>
<p>开发时依赖。</p>
</li>
<li><p>–save</p>
<p>运行时依赖</p>
</li>
</ul>
<h5 id="5-3-webpack中的其他文件安装"><a href="#5-3-webpack中的其他文件安装" class="headerlink" title="5.3 webpack中的其他文件安装"></a>5.3 webpack中的其他文件安装</h5><ol>
<li><p>package.json文件：这个文件时webpack的一些配置信息，而这个文件是通过，在当前项目的文件夹下通过<strong>npm init</strong> 初始化自动生成。</p>
</li>
<li><p>webpack 的每次打包文件都需要，指定路径</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">#使用webpack命令行，把main.js 文件打包到bundle.js文件</span><br><span class="line">webpack ./src/main.js ./dist/bundle.js</span><br></pre></td></tr></table></figure>

<ul>
<li><p>为了解决每次都要打包的问题，我们可以配置一些信息让他实现每次命令行不输入命令，只输入webpack 就可以实现自动打包到指定路径的效果</p>
</li>
<li><p>配置文件命令为webpack.config.js，配置信息入如下：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">#引入path依赖，这个是node.js中的依赖</span><br><span class="line"><span class="keyword">const</span> path = <span class="built_in">require</span>(<span class="string">&#x27;path&#x27;</span>)</span><br><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">	#入口（就是需要压缩的文件的入口）</span><br><span class="line">	<span class="attr">entry</span> : <span class="string">&#x27;./src/main.js&#x27;</span>,</span><br><span class="line">	#出口</span><br><span class="line">	<span class="attr">output</span>:&#123;</span><br><span class="line">		#压缩的路径其中_dirname 是node里面的全局变量，用来找到dist这个文件位置。（这样找到得是绝对路径，而且可以动态的找到找到路径）</span><br><span class="line">		<span class="attr">path</span>:path.resolve(_dirname,<span class="string">&#x27;dist&#x27;</span>),</span><br><span class="line">		#打包之后保存的文件名</span><br><span class="line">		<span class="attr">filename</span>:<span class="string">&#x27;bundle.js&#x27;</span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
</ol>
<h5 id="5-4-webpack-的全局安装和本地安装的区别："><a href="#5-4-webpack-的全局安装和本地安装的区别：" class="headerlink" title="5.4 webpack 的全局安装和本地安装的区别："></a>5.4 webpack 的全局安装和本地安装的区别：</h5><ul>
<li>当我们进入公司之后可能有一个项目正在开发，而这个项目是使用webpack3.60版本的，而我们电脑全局安装的是webpack4.2.0版本，这个时候我们如果使用全局的webpack4.20打包项目的话就会出现bug,所以我们需要在本地项目中安装一个局部的webpack3.60版本。跟项目匹配。</li>
</ul>
<h5 id="5-5-webpack-命令全局和本地的区别"><a href="#5-5-webpack-命令全局和本地的区别" class="headerlink" title="5.5 webpack 命令全局和本地的区别"></a>5.5 webpack 命令全局和本地的区别</h5><ul>
<li><p>只要在终端输入的命令肯定是全局的webpack，而用在项目的package.json 中的scripts：{}中定义的脚本命令是局部的，因为他会优先在本地找，找不到为在全局找。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">#package.json文件</span><br><span class="line">	<span class="attr">scripts</span>:&#123;</span><br><span class="line">		<span class="string">&#x27;build&#x27;</span>:<span class="string">&#x27;webpack&#x27;</span></span><br><span class="line">	&#125;</span><br><span class="line">#配置好之后,可以不用输入webpack，而是通过以下方式实现。</span><br><span class="line">	npm run build</span><br></pre></td></tr></table></figure></li>
<li><p>还有一种方式，当我们在局部安装好webpack之后会生成一个包，名字是node_modules，然后找到这个包里面的webpack运行webpack（这个也是本地的）。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">node_modules/.bin/webpack</span><br></pre></td></tr></table></figure></li>
<li><p>一般我们选择第一种方式运行webpack</p>
</li>
</ul>
<h5 id="5-6-webpack-的打包的规则"><a href="#5-6-webpack-的打包的规则" class="headerlink" title="5.6 webpack 的打包的规则"></a>5.6 webpack 的打包的规则</h5><ul>
<li>webpack打包首先入去入口文件里面去找，这里的入口文件就是src文件夹下的main.js/或者index.js，如果文件里面有依赖的话会找到对应的依赖文件一起打包。</li>
</ul>
<h5 id="5-7-webpack-的loader"><a href="#5-7-webpack-的loader" class="headerlink" title="5.7 webpack 的loader"></a>5.7 webpack 的loader</h5><ul>
<li>webpack 只负责处理依赖和打包，像是转换ES6到ES5，或者转化其他代码，webpack 不能处理，这时候可以依赖其他扩展来处理，就是<strong>loader</strong></li>
</ul>
<h6 id="5-71-css文件的loader"><a href="#5-71-css文件的loader" class="headerlink" title="5.71 css文件的loader"></a>5.71 css文件的loader</h6><ul>
<li><p>而Css文件跟入口函数没有任何依赖，<strong>我们收到把css文件引入会报错</strong>，这时候会提醒我们安装loader去处理css文件。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#main.js</span><br><span class="line">require(xxx.css)</span><br></pre></td></tr></table></figure>



<ul>
<li>首先我们可以去webpack官网上查找css-loader,然后命令行安装，再去wenpack.config.js中去配置相关信息。</li>
<li>但是css-loader,只负责将css文件打包，但是不负责引入到DOM中，这时候就需要用到style-loader,同样是命令行安装，配置信息。</li>
<li>有一点需要特别注意的是，我们在配置css-loader和style-loader 时，要注意一下代码</li>
</ul>
</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">module</span>:&#123;</span><br><span class="line">	<span class="attr">rules</span>:[</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="attr">test</span>:<span class="regexp">/\.css$/</span>,</span><br><span class="line">			#css-loader 只负责将css 文件加载</span><br><span class="line">			#style-loader 负责将样式添加到DOM中</span><br><span class="line">			#使用多个loader时，是从右到左（本来应该先css-loader,然后在style-loader，但是npm 这个执行的规则是先右后左，所以要反过来写。</span><br><span class="line">			<span class="attr">ues</span>:[<span class="string">&#x27;style-loader&#x27;</span>,<span class="string">&#x27;css-loader&#x27;</span>]</span><br><span class="line">		&#125;</span><br><span class="line">	]</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h5 id="5-8-webpack处理图片文件"><a href="#5-8-webpack处理图片文件" class="headerlink" title="5.8 webpack处理图片文件"></a>5.8 webpack处理图片文件</h5><p>webpack 处理图片分为两种情况，一种是图片下雨limit限制的大小，另外是大于limit限制的大小。</p>
<ul>
<li><p>首先我们需要在main.js入口文件中引入依赖</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">require(&#x27;xxx.css&#x27;)</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>然后就会提示我们安装loader，这个时候我们就可以安装url-loader,然后配置文件</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">modules:&#123;</span><br><span class="line">	<span class="attr">rules</span>:[</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="attr">test</span>:<span class="regexp">/\jpg|png|gif\jpeg/</span>,</span><br><span class="line">			use:[</span><br><span class="line">				&#123;</span><br><span class="line">					<span class="attr">loader</span>:<span class="string">&#x27;url-loader&#x27;</span>,</span><br><span class="line">					<span class="attr">options</span>:&#123;</span><br><span class="line">					#当加载的图片，小于limit时，会将图片编译成base64字符串形式。</span><br><span class="line">					#当加载图片，大于limit时，需要使用另外一个file-loader模块进行加载。我们只需要通过命令行安装即可。</span><br><span class="line">					<span class="attr">limit</span>:<span class="number">8691</span>,</span><br><span class="line">					#因为当大于limit时，file-loader会把图片打包，然后放到dist/文件下，这个时候我们给他一个命名规则</span><br><span class="line">					<span class="attr">name</span>:img/[name].[hash:<span class="number">8</span>].[ext]</span><br><span class="line">					&#125;</span><br><span class="line">				&#125;</span><br><span class="line">				</span><br><span class="line">			]</span><br><span class="line">		&#125;</span><br><span class="line">	]</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<ul>
<li>当图片大于limit时会出现引入的图片无法在DOM中显示，这是因为，我们的图片打包到了dist/文件下，但是路径还是在当前文件下，所以没有找到。我们只需要在配置文件的入口下面加上一段配置就行。</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">publicPath:<span class="string">&#x27;dist/&#x27;</span></span><br><span class="line"></span><br></pre></td></tr></table></figure></li>
</ul>
<h5 id="5-9-webpack-配置babel-loader-ES6转换成ES5"><a href="#5-9-webpack-配置babel-loader-ES6转换成ES5" class="headerlink" title="5.9 webpack 配置babel-loader(ES6转换成ES5)"></a>5.9 webpack 配置babel-loader(ES6转换成ES5)</h5><ul>
<li><p>命令行：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">npm install --save-dev babel-loader@7 babel-core babel-preset-es2015</span><br><span class="line"></span><br></pre></td></tr></table></figure></li>
<li><p>配置文件</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">modules:&#123;</span><br><span class="line">	<span class="attr">rules</span>:[</span><br><span class="line">		test:<span class="regexp">/\.js$/</span>,</span><br><span class="line">		#exclude 排除的意思，因为node_modules里面的文件不需要处理</span><br><span class="line">		<span class="attr">exclude</span>:<span class="regexp">/(node_modules|bower_components)/</span>,</span><br><span class="line">		use:&#123;</span><br><span class="line">		<span class="attr">loader</span>:<span class="string">&#x27;babel-loader&#x27;</span>,</span><br><span class="line">		<span class="attr">options</span>:&#123;</span><br><span class="line">			<span class="attr">presets</span>:[<span class="string">&#x27;es2015&#x27;</span>]</span><br><span class="line">		&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	]</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure></li>
</ul>
<h4 id="6-webpack-配置Vue"><a href="#6-webpack-配置Vue" class="headerlink" title="6.webpack 配置Vue"></a>6.webpack 配置Vue</h4><ol>
<li>安装vue的三种方式：<ul>
<li>直接下载应用</li>
<li>CDN引入</li>
<li>npm安装（模块化推荐方式）</li>
</ul>
</li>
</ol>
<h5 id="6-1安装vue-loader组件"><a href="#6-1安装vue-loader组件" class="headerlink" title="6.1安装vue-loader组件"></a>6.1安装vue-loader组件</h5><ul>
<li><p>当我们引入vue组件时，会报错，需要我们引入vue-loader</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">npm install --save-dev vue-loader vue-template-compiler </span><br><span class="line"></span><br></pre></td></tr></table></figure></li>
<li><p>然后配置信息</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">modules:&#123;</span><br><span class="line">	rules:&#123;</span><br><span class="line">		test:/.\vue$/,</span><br><span class="line">		use:[&#x27;vue-loader&#x27;]</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure></li>
<li><p><strong>需要注意的是</strong></p>
<p>当我们vue安装的版本大于15.00时，会报错，需要安装别的依赖，这个时候我们在package.json里手动把vue的版本改成13.00,这个时候再 执行下面的命令就行 了。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">npm install vue-loader</span><br><span class="line"></span><br></pre></td></tr></table></figure></li>
</ul>
<h4 id="7-webpack的扩展-Plugin"><a href="#7-webpack的扩展-Plugin" class="headerlink" title="7.webpack的扩展 Plugin"></a>7.webpack的扩展 Plugin</h4><ul>
<li>plugin 是webpack的一个扩展插件，而loader相当于webpack的一个转换器。</li>
</ul>
<ol>
<li><p>BannerPlugin</p>
<p>这个插件是用来处理，当我们打包结束之后可以在打包的文件里面看到我们定义的版权信息。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">#引入webpack</span><br><span class="line"><span class="keyword">const</span> webpack = <span class="built_in">require</span>(<span class="string">&#x27;webpack&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">	...</span><br><span class="line">	<span class="attr">plugins</span>:[</span><br><span class="line">		<span class="keyword">new</span> webpack.BannerPlugin(<span class="string">&#x27;最终解释权归xxx所有&#x27;</span>)</span><br><span class="line">	]</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure></li>
<li><p>打包html 的 plugin插件</p>
<p>目前，我们的index.html文件是存放在项目的根目录下的，我们知道，在真是发布项目的时候，发布的是dist文件夹中的内容，但是dist文件夹中如果没有index.html文件，那么打包的js文件也就没有意义了。所以我们需要将index.html文件打包到dist文件夹中，这个时候就可以用HtmlWebpackPlugin插件。</p>
<ul>
<li><p>HtmlWebpackPlugin 插件可以为我们做这些事情：</p>
<p><strong>自动生成一个index.html文件（可以指定模板来生成）</strong></p>
<p><strong>将打包的js文件，自动通过script标签插入到body中。</strong></p>
</li>
</ul>
</li>
</ol>
<ul>
<li><p>安装HtmlWebpackPlugin插件</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">npm install html-webpack-plugin --save-dev</span><br><span class="line"></span><br></pre></td></tr></table></figure></li>
<li><p>配置webpack.confing.js里面的内容</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">#导入依赖</span><br><span class="line"><span class="keyword">const</span> HtmlWebpackPlugin = <span class="built_in">require</span>(<span class="string">&#x27;html-webpack-plugin&#x27;</span>)</span><br><span class="line">#配置信息</span><br><span class="line"><span class="attr">plugins</span>:&#123;</span><br><span class="line">	<span class="keyword">new</span> HtmlWebpackPlugin(&#123;</span><br><span class="line">		#这里的template表示根据什么模板来生成html文件</span><br><span class="line">		<span class="attr">template</span>:<span class="string">&#x27;index.html&#x27;</span></span><br><span class="line">	&#125;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<ul>
<li>另外，我们需要删除，之前在output出口中配置的publicPath属性。否则插入的script标签中的src可能会有问题。</li>
</ul>
</li>
</ul>
<p>3.js压缩的plugin</p>
<p>在项目发布之前，我们必然要对js等文件进行压缩处理。</p>
<ul>
<li>这里我们就对打包的js文件进行压缩，我们使用一个第三方的插件，uglifyjs-webpack-plugin ,并且版本号指定1.1.1和cli2保持一致</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">npm install uglifyjs-webpack-plugin@<span class="number">1.1</span><span class="number">.1</span> --save-dev</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<ul>
<li><p>配置信息</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">#引入依赖</span><br><span class="line"><span class="keyword">const</span> UgfilyJsPlugin = <span class="built_in">require</span>(<span class="string">&#x27;ugfily-webpack-plugin&#x27;</span>)</span><br><span class="line">#配置信息</span><br><span class="line"><span class="attr">modules</span>:&#123;</span><br><span class="line">	...</span><br><span class="line">	<span class="attr">plugins</span>:&#123;</span><br><span class="line">		<span class="keyword">new</span> UglifyJsPlugin()</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure></li>
</ul>
<h4 id="8-webpack-搭建本地服务器"><a href="#8-webpack-搭建本地服务器" class="headerlink" title="8.webpack 搭建本地服务器"></a>8.webpack 搭建本地服务器</h4><ul>
<li><p>webpack提供了一个可选的本地开发服务，这个本地开发服务基于node.js搭建，内部使用express框架，可以实现我们想要的让浏览器自动刷新显示我们修改后的结果。</p>
</li>
<li><p>不过他是一个单独的模块，在webpack中使用它之前需要安装</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">npm install --save-dev webpack-dev-server@<span class="number">2.9</span><span class="number">.1</span></span><br><span class="line"></span><br></pre></td></tr></table></figure></li>
<li><p>配置信息</p>
<ul>
<li>devserver 也是作为webpack中的一个选项，选项本身可以设置一下属性：</li>
<li>contentBase:为哪一个文件提供本地服务，默认是根文件夹，我们这里填写’./dist’</li>
<li>port:端口号</li>
<li>inline:页面实时刷新</li>
<li>histortyApiFallback:在SPA页面中，依赖HTML5的history模式</li>
</ul>
</li>
<li><p>webpack.config.js文件配置的修改如下：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">deServer:&#123;</span><br><span class="line">	<span class="attr">contentBase</span>:<span class="string">&#x27;./dist&#x27;</span>,</span><br><span class="line">	<span class="attr">inline</span>:<span class="literal">true</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure></li>
</ul>
<p><strong>最重要的一点是：我们运行本地服务的命令：</strong></p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">webpack-dev-server</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<ul>
<li><p>但是因为是安装在局部，所以需要找到相对路径之后才能运行。</p>
<p>所以我们为了简化这个命令，再配置写信息在scripts脚本里面</p>
</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">scripts:&#123;</span><br><span class="line">	...</span><br><span class="line">	<span class="string">&quot;dev&quot;</span>:<span class="string">&#x27;webpack-dev-server --open&#x27;</span></span><br><span class="line">	#--open 表示的是直接打开浏览器，可带可不带</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h4 id="9-webpack-config-js配置文件分离"><a href="#9-webpack-config-js配置文件分离" class="headerlink" title="9.webpack.config.js配置文件分离"></a>9.webpack.config.js配置文件分离</h4><p>因为在webpack.config.js文件中既有，开发时依赖，也有运行时依赖，所以我们本次进行一个抽离，把开发时依赖和运行时依赖分开。</p>
<p>在根目录下新建一个build文件，然后在build文件夹下新建dev.config.js和base.config.js还有prod.config.js三个文件</p>
<p>其中base.config.js用来放置一些基础的配置，然后dev.config.js用来放置开发时依赖，而prod.config.js用来放置prod生产时依赖。</p>
<p>当把文件分离之后，这个时候我们需要安装一个包用来处理，我们文件的合并，因为base.config.js和dev.config.js需要在开发时合并，而base.config.js和prod.config.js需要在生产时合并。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">npm install webpack-merge --save-dev</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>安装之后需要一下命令</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">#dev.config.js</span><br><span class="line"><span class="keyword">const</span> WebpackMerge = <span class="built_in">require</span>(<span class="string">&#x27;webpack-merge&#x27;</span>)</span><br><span class="line"><span class="keyword">const</span> BaseConfig = <span class="built_in">require</span>(<span class="string">&#x27;./base.config.js&#x27;</span>)</span><br><span class="line">#合并设置</span><br><span class="line"><span class="built_in">module</span>.exports = WebpackMerge(BaseConfig,&#123;</span><br><span class="line">    <span class="attr">deServer</span>:&#123;</span><br><span class="line">        <span class="attr">contentBase</span>:<span class="string">&#x27;./dist&#x27;</span>,</span><br><span class="line">        <span class="attr">inline</span>:<span class="literal">true</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br><span class="line"></span><br></pre></td></tr></table></figure>



<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">#prod.config.js</span><br><span class="line"><span class="keyword">const</span> WebpackMerge = <span class="built_in">require</span>(<span class="string">&#x27;webpack-merge&#x27;</span>)</span><br><span class="line"><span class="keyword">const</span> BaseConfig = <span class="built_in">require</span>(<span class="string">&#x27;./base.config.js&#x27;</span>)</span><br><span class="line"><span class="keyword">const</span> UglifyJsWebpackPlugin = <span class="built_in">require</span>(<span class="string">&#x27;uglifyjs-webpack-plugin&#x27;</span>)</span><br><span class="line"><span class="built_in">module</span>.exports = WebpackMerge(BaseConfig,&#123;</span><br><span class="line">	<span class="attr">Plugin</span>:&#123;</span><br><span class="line">		<span class="keyword">new</span> UglifyJSWebpackPlugin()</span><br><span class="line">	&#125;</span><br><span class="line">&#125;)</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>配置好之后就可以删除原有webpack.config.js文件了，然后运行命令行之后发现报错：报错原因是没有webpack.config.js文件，这个时候我们可以修改package.json文件下的scripts脚本里的命令</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">scripts:&#123;</span><br><span class="line">	...</span><br><span class="line">	#因为自动找的话，只会找webpack.config.js文件，我们这里手动指定路径</span><br><span class="line">	<span class="string">&quot;build&quot;</span>:<span class="string">&quot;webpack --config ./build/prod.config.js&quot;</span>,</span><br><span class="line">	<span class="string">&quot;dev&quot;</span>:<span class="string">&quot;webpack-dev-server --config ./build/dev.config.js&quot;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>配置好之后在运行，可以，没有错误，但是还有问题，就是打包的文件路径有问题。因为原来配置的打包的文件的路径是在webpack.config.js文件的同一级目录的dist文件夹下，现在配置文件修改到了build文件夹下了，这个时候打包的文件默认安装到build文件夹下。所以我们还得修改打包路径，在package.json文件夹下通过修改</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">output:&#123;</span><br><span class="line">	#修改路径为 <span class="string">&#x27;../dist&#x27;</span></span><br><span class="line">	<span class="attr">path</span>:path.resolve(_dirname,<span class="string">&#x27;../dist&#x27;</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h4 id="10-Vue-CLI-脚手架的介绍"><a href="#10-Vue-CLI-脚手架的介绍" class="headerlink" title="10.Vue CLI 脚手架的介绍"></a>10.Vue CLI 脚手架的介绍</h4><p>在我们项目开发中一般不会全程手动配置webpack，我们可以通过CLI脚手架来自动配置webpack信息，来实现上述的功能。</p>
<ul>
<li>Vue CLI也是依赖于 node.js的，所以使用之前要安装node.js</li>
<li>同时Vue CLI也依赖于webpack ，所以要提前安装node和webpack</li>
</ul>
<h5 id="10-1-cnpm-安装"><a href="#10-1-cnpm-安装" class="headerlink" title="10.1  cnpm 安装"></a>10.1  cnpm 安装</h5><p>你可以使用淘宝定制的cnpm(gzip压缩支持)命令行工具代替默认的npm:</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">npm install -g cnpm --registry=https:<span class="comment">//registry.npm.taobao.org</span></span><br><span class="line">#这样就可以使用cnpm命令来安装模块了</span><br><span class="line">cnpm install [name]</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h5 id="10-2-Vue-CLI-安装"><a href="#10-2-Vue-CLI-安装" class="headerlink" title="10.2 Vue CLI 安装"></a>10.2 Vue CLI 安装</h5><p>脚手架一般都是全局安装</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">npm install -g @vue/cli</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p> 通过vue -version 可以查看版本，这里是3.多版本的，是不能够使用CLI2版本创建项目的。所以这个时候我们需要根据官网文档说明，通过命令行拉取2.x模板</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">npm install -g @vue/cli-init</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h5 id="10-3-通过vue-CLI创建项目"><a href="#10-3-通过vue-CLI创建项目" class="headerlink" title="10.3 通过vue CLI创建项目"></a>10.3 通过vue CLI创建项目</h5><p>vue CLI2初始化项目：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">vue init webpack my-project</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h4 id="11-前端渲染，前端路由、后端渲染，后端路由"><a href="#11-前端渲染，前端路由、后端渲染，后端路由" class="headerlink" title="11.前端渲染，前端路由、后端渲染，后端路由"></a>11.前端渲染，前端路由、后端渲染，后端路由</h4><ol>
<li>后端渲染：就是以前请求一个url的时候会向服务器发送请求，然后在服务器通过jsp代码html+css，已经通过Java跟数据库动态链接来实现整个页面的渲染，然后把渲染好的页面发送给浏览器(只发送HTML+css)。</li>
<li>后端路由：就是这种通过后端服务器来配置每个页面和url的映射关系称为后端路由。</li>
<li>前端渲染：前端渲染主要是通过url请求服务端数据，然后获取数据，通过js代码处理数据，动态的展示单浏览器页面上。</li>
<li>前端路由：就是设计SPA，单页面富应用，一般只有一个index.html文件，通过前端路由映射每个url和页面，显示数据的切换，但是页面只有一个。只是数据通过路由映射发生变化。</li>
</ol>
<h5 id="11-1-使用路由"><a href="#11-1-使用路由" class="headerlink" title="11.1 使用路由"></a>11.1 使用路由</h5><ul>
<li><p>路由的安装很简单就不说了</p>
</li>
<li><p><router-link>:该标签是一个vue-router 已经内置的组件，它会北渲染成一个a标签。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">#点击首页跳转到对应的路径</span><br><span class="line">&lt;router-link to=<span class="string">&quot;/home&quot;</span>&gt;首页&lt;/router-link&gt;</span><br><span class="line"><span class="xml"><span class="tag">&lt;<span class="name">router-link</span> <span class="attr">to</span>=<span class="string">&quot;/about&quot;</span>&gt;</span>关于<span class="tag">&lt;/<span class="name">router-link</span>&gt;</span></span></span><br><span class="line"></span><br></pre></td></tr></table></figure></li>
<li><p><router-view>:该标签会根据当前的路径，动态的渲染出不同的组件</p>
</li>
<li><p>router-link 补充</p>
<ol>
<li><p>tag 可以指定<router-link>之后渲染成什么组件，比如上面的代码会被渲染成一个Li标签，而不是a标签。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;router-link tag=&quot;li to=&quot;/home&quot;&gt;&lt;router-link&gt;</span><br><span class="line"></span><br></pre></td></tr></table></figure></li>
<li><p>replace:不会留下history记录，所以指定replace的情况下，回退键不能返回到上一个界面中。</p>
</li>
<li><p>active-link-class:<router-link>对应的路由匹配成功时，会给当前元素设置一个active–link-class的class,设置active-class可以修改默认名称。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> router = <span class="keyword">new</span> VueRouter(&#123;</span><br><span class="line">	routes,</span><br><span class="line">	#这个是设置url已history显示，而不是通过#hash的方式</span><br><span class="line">	<span class="attr">mode</span>:history,</span><br><span class="line">	#这个是修改默认添加类的名字</span><br><span class="line">	<span class="attr">linkActiveClass</span>:<span class="string">&#x27;active-class&#x27;</span></span><br><span class="line">&#125;)</span><br><span class="line"></span><br></pre></td></tr></table></figure></li>
</ol>
</li>
</ul>
<h5 id="11-2动态路由"><a href="#11-2动态路由" class="headerlink" title="11.2动态路由"></a>11.2动态路由</h5><ol>
<li><p>使用路由：</p>
<ul>
<li><p>首先配置路由信息</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">#vue-router 的index.js</span><br><span class="line"><span class="keyword">const</span> routes:[</span><br><span class="line">	&#123;	</span><br><span class="line">		#动态在后面拼接字符串iid</span><br><span class="line">		<span class="attr">path</span>:<span class="string">&#x27;./test/:iid&#x27;</span>,</span><br><span class="line">		<span class="attr">compontent</span>:Test</span><br><span class="line">	&#125;</span><br><span class="line">]</span><br><span class="line"></span><br></pre></td></tr></table></figure></li>
<li><p>然后去根组件下动态配置</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">#App.vue</span><br><span class="line">&lt;router-link v-bind:to=<span class="string">&quot;&#x27;/test/&#x27;+useId&quot;</span>&gt;&lt;router-link&gt;</span><br><span class="line"><span class="xml"><span class="tag">&lt;<span class="name">router-view</span>&gt;</span><span class="tag">&lt;/<span class="name">router-view</span>&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span>&#123;</span><br><span class="line">	<span class="attr">name</span>:<span class="string">&quot;App&quot;</span>,</span><br><span class="line">	<span class="function"><span class="title">data</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">		<span class="keyword">return</span> &#123;</span><br><span class="line">		<span class="attr">useId</span>:lisi</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure></li>
</ul>
</li>
</ol>
<h5 id="11-3-router和route"><a href="#11-3-router和route" class="headerlink" title="11.3 router和route"></a>11.3 router和route</h5><p>$router 是表示new VueRouter()实例化的对象，在每个页面都可以调用，也可以使用push方法和replace方法。</p>
<p>$route 表示的是当前哪个路由活跃就表示哪个路由。</p>
<h5 id="11-4-路由的懒加载"><a href="#11-4-路由的懒加载" class="headerlink" title="11.4 路由的懒加载"></a>11.4 路由的懒加载</h5><p>路由的 懒加载就是我们最后打包的时候会把我们的css、js 、html代码分开打包，如果都打包到一个js 文件里，会造成我们浏览器去请求静态服务器的时候会导致文件过大，浏览器请求过程中会出现页面空白的情况。所以需要分开打包，这也就是路由的懒加载，同时打包的JS文件也会被分成三个文件和对应的每个组件的js。</p>
<ul>
<li><p>第一个就是app.js ：里面存放的是我们主要的业务代码，自己写的代码。</p>
</li>
<li><p>第二就是manifest.js :里面存放的是低层支撑的代码，用来处理不同文件代码之间的关系。</p>
</li>
<li><p>第三个就是vendor.js：里面存放的就是第三方提供的代码。vue-router,vue cli等。</p>
</li>
<li><p>对应的路由组件js,一般是配置的有几个路由组件，就会打包成几个js文件。</p>
</li>
<li><p>路由懒加载的格式是</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#router 的 index.js文件</span><br><span class="line">const Home = ()=&gt; import(&#x27;../components/Home&#x27;)</span><br><span class="line"></span><br></pre></td></tr></table></figure></li>
</ul>
<h5 id="11-5-路由嵌套"><a href="#11-5-路由嵌套" class="headerlink" title="11.5.路由嵌套"></a>11.5.路由嵌套</h5><p>如果我们想在原有组件下，新增路由，这就需要路由嵌套</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">#router index.js文件夹</span><br><span class="line">	<span class="keyword">const</span> routes:[</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="attr">path</span>:<span class="string">&#x27;/home&#x27;</span>,</span><br><span class="line">			<span class="attr">component</span>:Home</span><br><span class="line">		&#125;,</span><br><span class="line">		#在原来的路由下新增路由。</span><br><span class="line">		<span class="attr">children</span>:[</span><br><span class="line">			&#123;	#子路径不用加/</span><br><span class="line">				path:<span class="string">&#x27;news&#x27;</span>,</span><br><span class="line">				<span class="attr">component</span>:<span class="string">&#x27;News&#x27;</span></span><br><span class="line">			&#125;,</span><br><span class="line">			&#123;</span><br><span class="line">				<span class="attr">path</span>:<span class="string">&#x27;message&#x27;</span>,</span><br><span class="line">				<span class="attr">component</span>:<span class="string">&#x27;Message&#x27;</span></span><br><span class="line">			&#125;</span><br><span class="line">		]</span><br><span class="line">	]</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<ul>
<li><p>然后在Home.vue里面添加路由组件</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">#Home.vue 文件</span><br><span class="line">	&lt;template&gt;</span><br><span class="line">		#路径格式参照下面</span><br><span class="line">		&lt;router-link to=<span class="string">&quot;/home/news&quot;</span>&gt;消息&lt;/router-link&gt;</span><br><span class="line">		&lt;router-link to=&quot;/home/message&quot;&gt;通知&lt;router-link&gt;</span><br><span class="line">		&lt;router-view&gt;&lt;/router-view&gt;</span><br><span class="line"></span><br></pre></td></tr></table></figure></li>
</ul>
<h5 id="11-6传递参数"><a href="#11-6传递参数" class="headerlink" title="11.6传递参数"></a>11.6传递参数</h5><ol>
<li><p>通过字符串传递参数：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">#第一种方式通过字符串传递参数</span><br><span class="line">&lt;router-link :to=<span class="string">&quot;&#x27;/user/&#x27;+useId&quot;</span>&gt;档案&lt;/router-link&gt;</span><br><span class="line">#第二种方式，通过query传递参数</span><br><span class="line">&lt;router-link :to=<span class="string">&quot;&#123;path:&#x27;/profile&#x27;,query:&#123;name:&#x27;why&#x27;,age:18,height:1.88&#125;&#125;&quot;</span>&gt;档案&lt;/router-link&gt;</span><br><span class="line"></span><br></pre></td></tr></table></figure></li>
</ol>
<h5 id="11-7生命周期函数"><a href="#11-7生命周期函数" class="headerlink" title="11.7生命周期函数"></a>11.7生命周期函数</h5><ol>
<li>created() :当组件被创建好之后回调这个函数。</li>
<li>mounted() : 当template模板挂载到DOM上之后，会回调这个函数。<ul>
<li>在mounted()中获取组件的offsetTop的值，根本获取不到，因为在mounted()还没有值，没有渲染。</li>
</ul>
</li>
<li>updated() : 当页面发生刷新的时候会回调这个函数。<ul>
<li>在updatated()中获取组件的offsetTop值，获取的值不对，this.$refs.params.$el压根没有渲染。</li>
<li>this.nextTick(()=&gt;{}),获取的值也不对，原因是根据最新的数据，对应的DOM已经被渲染出来了，但是图片依然没有加载完（目前通过offsetTop获取的值是不包含图片的）</li>
</ul>
</li>
<li>destroyed() :当组件发生切换的时候回到用这个函数。</li>
<li>activated() :当组件是活跃的状态时，会调用这个函数。</li>
<li>deactivated() :当组件不是活跃的状态时，会调用这个函数。<ul>
<li><strong>activated 和deactivated 这两个方法，只有组件被keep-alive包含的时候才有效。</strong></li>
</ul>
</li>
</ol>
<h5 id="11-8-导航守卫函数"><a href="#11-8-导航守卫函数" class="headerlink" title="11.8 导航守卫函数"></a>11.8 导航守卫函数</h5><ul>
<li><p>需求：</p>
<p>当我们想要在首页切换每个组件让导航栏里面的title显示每个组件对应的title时，这个时候我们可以在每个组件内定义一个生命周期函数实现</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="title">created</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">	<span class="built_in">document</span>.title = <span class="built_in">this</span>.$route.title</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>虽然这种方式可以实现，但是需要每个组件都要写入一段这个代码，比较麻烦，所以我们想到了另外一个方法，使用路由守卫函数，监听路由的变化。</p>
</li>
<li><p>改进代码</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">#router 里面的index.js文件</span><br><span class="line">	#beforeEach也称为前置守卫（guard）</span><br><span class="line">	router.beforeEach(<span class="function">(<span class="params">to,<span class="keyword">from</span>,next</span>)=&gt;</span>&#123;</span><br><span class="line">		<span class="comment">//从from跳转到to,meta是我们在路由中配置的参数</span></span><br><span class="line">		<span class="built_in">document</span>.title = to.matched[<span class="number">0</span>].meta.title</span><br><span class="line">		#next()必须要加上，用来控制下一步。</span><br><span class="line">		next()</span><br><span class="line">	&#125;)</span><br><span class="line"></span><br></pre></td></tr></table></figure></li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">const route = [</span><br><span class="line">	&#123;</span><br><span class="line">		path:&#x27;/home&#x27;,</span><br><span class="line">		component:Home,</span><br><span class="line">		meta:&#123;</span><br><span class="line">			title:&#x27;首页&#x27;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">]</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h6 id="11-8-1全局守卫、路由独享守卫、组件守卫"><a href="#11-8-1全局守卫、路由独享守卫、组件守卫" class="headerlink" title="11.8.1全局守卫、路由独享守卫、组件守卫"></a>11.8.1全局守卫、路由独享守卫、组件守卫</h6><ul>
<li>有两个，分别是前置守卫(beforEach)，还有后置钩子(afterEach)<ul>
<li>其中后置钩子不需要主动调用next()，内部自动调用。</li>
</ul>
</li>
<li>路由独享守卫</li>
<li>组件守卫</li>
</ul>
<h5 id="11-9-keep-alive和router-view"><a href="#11-9-keep-alive和router-view" class="headerlink" title="11.9 keep-alive和router-view"></a>11.9 keep-alive和router-view</h5><ul>
<li><p>keep-alive是vue 内置的一个组件，可以使被包含的组件保留状态，或避免重新渲染。</p>
<ul>
<li>keep-alive :有两个属性，分别是include，和exclude（排除）</li>
<li>indclude–字符串或正则表达式，只有匹配的组件才会被缓存。</li>
<li>exclude–字符串或正则表达式，任何匹配的组件都不会被缓存。</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">//exclude中的东西不要加空格</span></span><br><span class="line">&lt;keep-alive exclude=<span class="string">&quot;Profile,User&quot;</span>&gt;</span><br><span class="line">	<span class="xml"><span class="tag">&lt;<span class="name">router-view</span>/&gt;</span></span></span><br><span class="line">&lt;/keep-alive&gt;</span><br><span class="line"></span><br></pre></td></tr></table></figure></li>
<li><p>router-view 也是一个组件，如果直接被包在keep-alive里面，所有的路径匹配到的视图组件也都会被缓存。</p>
</li>
</ul>
<h4 id="12-Promise的介绍"><a href="#12-Promise的介绍" class="headerlink" title="12.Promise的介绍"></a>12.Promise的介绍</h4><ul>
<li><p>​    什么事promise？</p>
<p>Promise 是异步编程的一种解决方案。</p>
</li>
<li><p>那什么时候我们回来处理异步事件呢？</p>
<ul>
<li>一种很常见的场景就是网络请求了。</li>
<li>我们封装一个网络请求的函数，因为不能立即拿到结果，所以不能像简单的3+4=7一样将结果返回出去。</li>
<li>所以往往我们会传入另一个函数，在数据请求成功时，将数据通过传入的函数回调出去。</li>
<li>如果只是一个简单的网络请求，那么这种方案不会给我们带来很大的麻烦。</li>
<li>但是当网络请求非常复杂时，就会出现回调地狱。</li>
</ul>
</li>
<li><p>简单总结一下就是（当我们进行复杂的网络请求时，如果是同步事件的话，那么相当于在请求的这段时间我们的浏览器要等到请求数据的到来，什么也不做，这会导致页面的空开，也称阻塞。这种方式非常不好，所以网络请求肯定是异步操作，然后通过传递参数，在请求成功时，通过回调把数据回调出来。</p>
</li>
</ul>
<h5 id="12-1-Promise的第一种写法"><a href="#12-1-Promise的第一种写法" class="headerlink" title="12.1  Promise的第一种写法"></a>12.1  Promise的第一种写法</h5><ul>
<li><p>new —&gt; 构造函数（1.保存一些状态信息，2.执行传入的函数）。</p>
</li>
<li><p>在执行传入的回调函数时，会传入两个参数，resolve，reject本身又是函数。</p>
</li>
<li><p>处理的函数一般都写在then和catch方法里面，这样结构清晰，便于维护。而resolve和reject只是取到数据，不进行处理。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">new</span> Promime(<span class="function">(<span class="params">resolve,reject</span>)=&gt;</span> &#123;</span><br><span class="line"><span class="built_in">setTimeout</span>(<span class="function">()=&gt;</span>&#123;</span><br><span class="line">	<span class="comment">//成功的时候调用 resolve</span></span><br><span class="line">	<span class="comment">//resolve(&#x27;Hello World&#x27;)</span></span><br><span class="line">	<span class="comment">//失败的时候调用reject.</span></span><br><span class="line">	reject(<span class="string">&#x27;Error&#x27;</span>)</span><br><span class="line">&#125;,<span class="number">1000</span>)</span><br><span class="line">&#125;).then(<span class="function">(<span class="params">data</span>)=&gt;</span>&#123;</span><br><span class="line">	<span class="built_in">console</span>.log(data)</span><br><span class="line">	<span class="built_in">console</span>.log(data)</span><br><span class="line">	<span class="built_in">console</span>.log(data)</span><br><span class="line">	<span class="built_in">console</span>.log(data)</span><br><span class="line">	<span class="built_in">console</span>.log(data)</span><br><span class="line">&#125;).catch(<span class="function"><span class="params">err</span>=&gt;</span>&#123;</span><br><span class="line">	<span class="built_in">console</span>.log(err)</span><br><span class="line">&#125;)</span><br><span class="line"></span><br></pre></td></tr></table></figure></li>
</ul>
<h5 id="12-2-Promise的第二种写法"><a href="#12-2-Promise的第二种写法" class="headerlink" title="12.2 Promise的第二种写法"></a>12.2 Promise的第二种写法</h5><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve,reject</span>)=&gt;</span>&#123;</span><br><span class="line">	<span class="built_in">setTimeout</span>(<span class="function">()=&gt;</span>&#123;</span><br><span class="line">		<span class="comment">//成功的信息</span></span><br><span class="line">		resolve(<span class="string">&#x27;Hello Vue.js&#x27;</span>)</span><br><span class="line">		<span class="comment">//返回错误信息</span></span><br><span class="line">		reject(<span class="string">&#x27;Error message&#x27;</span>)</span><br><span class="line">	&#125;，<span class="number">1000</span>)</span><br><span class="line">	<span class="comment">//then(函数1，函数2)，函数1用来处理成功，函数2用来处理失败</span></span><br><span class="line">&#125;).then(<span class="function"><span class="params">data</span>=&gt;</span>&#123;</span><br><span class="line">	<span class="built_in">console</span>.log(data)</span><br><span class="line">&#125;,<span class="function"><span class="params">err</span>=&gt;</span>&#123;</span><br><span class="line">	<span class="built_in">console</span>.log(err)</span><br><span class="line">&#125;)</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h5 id="12-3-Promise-的链式调用"><a href="#12-3-Promise-的链式调用" class="headerlink" title="12.3 Promise 的链式调用"></a>12.3 Promise 的链式调用</h5><ol>
<li>第一种链式调用的书写方式</li>
</ol>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve,reject</span>)=&gt;</span>&#123;</span><br><span class="line">	#第一次网络请求</span><br><span class="line">	<span class="built_in">setTimeout</span>(<span class="function">()=&gt;</span>&#123;</span><br><span class="line">		resolve(<span class="string">&#x27;Hello Vue.js&#x27;</span>)</span><br><span class="line">	&#125;,<span class="number">1000</span>)</span><br><span class="line">&#125;).then(<span class="function"><span class="params">res</span>=&gt;</span>&#123;</span><br><span class="line">	#处理拿到的数据</span><br><span class="line">	<span class="built_in">console</span>.log(res)</span><br><span class="line">	<span class="built_in">console</span>.log(res)</span><br><span class="line">	<span class="built_in">console</span>.log(res)</span><br><span class="line">	<span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve,reject</span>)=&gt;</span>&#123;</span><br><span class="line">		#第二次网络请求</span><br><span class="line">		<span class="built_in">setTimeout</span>(<span class="function">()=&gt;</span>&#123;</span><br><span class="line">			resolve(<span class="string">&#x27;Hellow Python&#x27;</span>)</span><br><span class="line">		&#125;,<span class="number">1000</span>)</span><br><span class="line">	&#125;)</span><br><span class="line">&#125;).then(<span class="function"><span class="params">res</span>=&gt;</span>&#123;</span><br><span class="line">	<span class="built_in">console</span>.log(res)</span><br><span class="line">	<span class="built_in">console</span>.log(res)</span><br><span class="line">	<span class="built_in">console</span>.log(res)</span><br><span class="line">	<span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve,reject</span>)=&gt;</span>&#123;</span><br><span class="line">		#第三次网络请求</span><br><span class="line">		<span class="built_in">setTimeout</span>(()=&#123;</span><br><span class="line">			resolve(<span class="string">&#x27;Hellow JS&#x27;</span>)</span><br><span class="line">		&#125;,<span class="number">1000</span>)</span><br><span class="line">	&#125;)</span><br><span class="line">&#125;).then(<span class="function"><span class="params">res</span>=&gt;</span>&#123;</span><br><span class="line">	<span class="built_in">console</span>.log(res)</span><br><span class="line">	<span class="built_in">console</span>.log(res)</span><br><span class="line">	<span class="built_in">console</span>.log(res)</span><br><span class="line">&#125;)</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>​    2.第二种链式调用方式：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="params">resolve</span>=&gt;</span>&#123;</span><br><span class="line">	resolve(res+<span class="string">&#x27;111&#x27;</span>)</span><br><span class="line">&#125;)的简写：<span class="built_in">Promise</span>.resolve(res+<span class="string">&#x27;111&#x27;</span>)</span><br><span class="line"></span><br></pre></td></tr></table></figure>



<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve,reject</span>)=&gt;</span>&#123;</span><br><span class="line">	<span class="built_in">setTimeout</span>(<span class="function">()=&gt;</span>&#123;</span><br><span class="line">		resolve(<span class="string">&#x27;aaa&#x27;</span>)</span><br><span class="line">	&#125;,<span class="number">1000</span>)</span><br><span class="line">&#125;).then(<span class="function"><span class="params">res</span>=&gt;</span>&#123;</span><br><span class="line">	<span class="built_in">console</span>.log(res,<span class="string">&#x27;第一层处理的10行代码&#x27;</span>)</span><br><span class="line">	</span><br><span class="line">	<span class="comment">//对结果进行第一次处理</span></span><br><span class="line">	<span class="keyword">return</span> <span class="built_in">Promise</span>.resolve(res+<span class="string">&#x27;111&#x27;</span>)</span><br><span class="line">&#125;).then(<span class="function"><span class="params">res</span>=&gt;</span>&#123;</span><br><span class="line">	<span class="built_in">console</span>.log(res,<span class="string">&#x27;第二层的10行处理代码&#x27;</span>)</span><br><span class="line">	<span class="comment">//对结果进行第二次处理</span></span><br><span class="line">	<span class="keyword">return</span> <span class="built_in">Promise</span>.resolve(res+<span class="string">&#x27;222&#x27;</span>)</span><br><span class="line">&#125;).then(<span class="function"><span class="params">res</span>=&gt;</span>&#123;</span><br><span class="line">	<span class="built_in">console</span>.log(res,<span class="string">&#x27;第三层的10行处理代码&#x27;</span>)</span><br><span class="line">&#125;)</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>​    3.链式调用的第三种写法：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">return</span> <span class="built_in">Promise</span>.resolve(res+<span class="string">&#x27;111&#x27;</span>)的简写</span><br><span class="line"><span class="keyword">return</span> res+<span class="string">&#x27;111&#x27;</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve,reject</span>)=&gt;</span>&#123;</span><br><span class="line">	<span class="built_in">setTimeout</span>(<span class="function">()=&gt;</span>&#123;</span><br><span class="line">		resolve(<span class="string">&#x27;aaa&#x27;</span>)</span><br><span class="line">	&#125;,<span class="number">1000</span>)</span><br><span class="line">&#125;).then(<span class="function"><span class="params">res</span>=&gt;</span>&#123;</span><br><span class="line">	<span class="built_in">console</span>.log(res,<span class="string">&#x27;第一层处理的10行代码&#x27;</span>)</span><br><span class="line">	</span><br><span class="line">	<span class="comment">//对结果进行第一次处理 简写的方式</span></span><br><span class="line">	<span class="keyword">return</span> res+<span class="string">&#x27;111&#x27;</span></span><br><span class="line">&#125;).then(<span class="function"><span class="params">res</span>=&gt;</span>&#123;</span><br><span class="line">	<span class="built_in">console</span>.log(res,<span class="string">&#x27;第二层的10行处理代码&#x27;</span>)</span><br><span class="line">	<span class="comment">//对结果进行第二次处理，简写的方式</span></span><br><span class="line">	<span class="keyword">return</span> res+<span class="string">&#x27;222&#x27;</span></span><br><span class="line">&#125;).then(<span class="function"><span class="params">res</span>=&gt;</span>&#123;</span><br><span class="line">	<span class="built_in">console</span>.log(res,<span class="string">&#x27;第三层的10行处理代码&#x27;</span>)</span><br><span class="line">&#125;)</span><br><span class="line"></span><br></pre></td></tr></table></figure>



<h5 id="12-4-Promise-的all方法"><a href="#12-4-Promise-的all方法" class="headerlink" title="12.4 Promise 的all方法"></a>12.4 Promise 的all方法</h5><p>​    当我们的项目中要请求到数据，必须在对两个url进行都完成时才能够取到数据，这个时候就可以使用Promise.all([])方法，里面必须是可迭代对象interator，也就是可以遍历的。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">Promise</span>.all([</span><br><span class="line">	#网络请求<span class="number">1</span></span><br><span class="line">	<span class="keyword">new</span> <span class="built_in">Promise</span>((resolve,<span class="function"><span class="params">reject</span>=&gt;</span>&#123;</span><br><span class="line">		<span class="built_in">setTimeout</span>(<span class="function">()=&gt;</span>&#123;</span><br><span class="line">			resolve(&#123;<span class="attr">name</span>:<span class="string">&#x27;why&#x27;</span>,<span class="attr">age</span>:<span class="number">18</span>&#125;)</span><br><span class="line">		&#125;,<span class="number">1000</span>)</span><br><span class="line">	&#125;),</span><br><span class="line">	#网络请求<span class="number">2</span></span><br><span class="line">	<span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve,reject</span>)=&gt;</span>&#123;</span><br><span class="line">		<span class="built_in">setTimeout</span>(<span class="function">()=&gt;</span>&#123;</span><br><span class="line">			resolve(&#123;<span class="attr">name</span>:kobe,<span class="attr">age</span>:<span class="number">19</span>&#125;)</span><br><span class="line">		&#125;,<span class="number">2000</span>)</span><br><span class="line">	&#125;)</span><br><span class="line">]).then(<span class="function"><span class="params">results</span>=&gt;</span>&#123;</span><br><span class="line">		#results，取到的是一个数组，包含上面两个网络请求的数据</span><br><span class="line">		<span class="built_in">console</span>.log(results)</span><br><span class="line">	&#125;)</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h4 id=""><a href="#" class="headerlink" title=""></a></h4><h4 id="13-axios-网络请求"><a href="#13-axios-网络请求" class="headerlink" title="13.axios 网络请求"></a>13.axios 网络请求</h4><ol>
<li><p>​    axios(config):</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">axios(&#123;</span><br><span class="line">	<span class="attr">url</span>:<span class="string">&#x27;https://www.baidu.com&#x27;</span></span><br><span class="line">&#125;).then(<span class="function"><span class="params">res</span>=&gt;</span>&#123;</span><br><span class="line">	<span class="built_in">console</span>.log(res)</span><br><span class="line">&#125;)</span><br><span class="line"></span><br></pre></td></tr></table></figure></li>
<li><p>axios(config):字符串拼接的模式</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">axios(&#123;</span><br><span class="line">	<span class="attr">url</span>:<span class="string">&#x27;http://123.207.32.32:8000/home/data&#x27;</span>,</span><br><span class="line">	<span class="comment">//专门针对get请求的参数拼接</span></span><br><span class="line">	<span class="attr">params</span>:&#123;</span><br><span class="line">		<span class="attr">type</span>:<span class="string">&#x27;pop&#x27;</span>,</span><br><span class="line">		<span class="attr">page</span>:<span class="number">1</span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;).then(<span class="function"><span class="params">res</span>=&gt;</span>&#123;</span><br><span class="line">	<span class="built_in">console</span>.log(res)</span><br><span class="line">&#125;)</span><br><span class="line"></span><br></pre></td></tr></table></figure></li>
</ol>
<h5 id="13-1-使用axios发送并发请求"><a href="#13-1-使用axios发送并发请求" class="headerlink" title="13.1 使用axios发送并发请求"></a>13.1 使用axios发送并发请求</h5><ul>
<li>​    使用axios.all可以放入多个请求的数组。<ul>
<li>axios.all([ ]) 返回的结果是一个数组，使用axios.spread 可将数组[res1,res2]展开为res1,res2。</li>
</ul>
</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">axios.all([axios.get(<span class="string">&#x27;http://123.207.32.32:8000/category&#x27;</span>),</span><br><span class="line">	axios.get(<span class="string">&#x27;http://123.207.32.32:8000/home/data&#x27;</span>,&#123;</span><br><span class="line">	<span class="attr">params</span>:&#123;<span class="attr">type</span>:<span class="string">&#x27;sell&#x27;</span>,<span class="attr">page</span>:<span class="number">1</span>&#125;&#125;)</span><br><span class="line">]).then(axios.spread(<span class="function">(<span class="params">res1,res2</span>)=&gt;</span>&#123;</span><br><span class="line">	<span class="built_in">console</span>.log(res1);</span><br><span class="line">	<span class="built_in">console</span>.log(res2)</span><br><span class="line">&#125;))</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h5 id="13-2-使用第三方框架的注意点"><a href="#13-2-使用第三方框架的注意点" class="headerlink" title="13.2 使用第三方框架的注意点"></a>13.2 使用第三方框架的注意点</h5><ul>
<li>当我们引用第三方框架的时候，切记不能让每个vue的文件都对第三方框架产生依赖，也就是每个vue文件都导入第三方的框架，这样如果有一天这个第三方框架不能用了就会导致，我们每个vue文件都要进行修改。</li>
</ul>
<h5 id="13-3-axios-的全局配置"><a href="#13-3-axios-的全局配置" class="headerlink" title="13.3 axios 的全局配置"></a>13.3 axios 的全局配置</h5><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">axios.defaults.baseURL = <span class="string">&#x27;http://123.207.32.32:8000&#x27;</span></span><br><span class="line">axios.defaults.timeoute = <span class="number">5000</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<ul>
<li>全局配置有缺点，就是当我们对一个服务器请求的人数很多时这时候服务器可能会受不了。</li>
<li>所以我们后期会使用nginx分布式部署，就是有多个服务器，然后当有很多人请求时,我们会通过nginx分布式把请求分散到多个服务器上，减轻单个服务器的请求压力。</li>
<li>所以这个时候多个服务器的baseURL地址不同，我们不能使用全局配置。这个时候就有个 axios实例的方式，更合适。</li>
</ul>
<h5 id="13-4-axios-的实例对象"><a href="#13-4-axios-的实例对象" class="headerlink" title="13.4 axios 的实例对象"></a>13.4 axios 的实例对象</h5><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> instance = axios.create(&#123;</span><br><span class="line">	baseURL = <span class="string">&#x27;http://123.207.32.32:8000&#x27;</span>,</span><br><span class="line">	timeout = <span class="number">5000</span></span><br><span class="line">&#125;)</span><br><span class="line">instance(&#123;</span><br><span class="line">	<span class="attr">url</span>:<span class="string">&#x27;/home/multidata&#x27;</span></span><br><span class="line">&#125;).then(<span class="function"><span class="params">res</span>=&gt;</span>&#123;</span><br><span class="line">	<span class="built_in">console</span>.log(res)</span><br><span class="line">&#125;)</span><br><span class="line">instance(&#123;</span><br><span class="line">	<span class="attr">url</span>:<span class="string">&#x27;/home/data&#x27;</span></span><br><span class="line">&#125;).then(<span class="function"><span class="params">res</span>=&gt;</span>&#123;</span><br><span class="line">	<span class="built_in">console</span>.log(res)</span><br><span class="line">&#125;)</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h5 id="13-5-封装axios-函数文件-—-gt-传入三个参数"><a href="#13-5-封装axios-函数文件-—-gt-传入三个参数" class="headerlink" title="13.5 封装axios 函数文件 —&gt;传入三个参数"></a>13.5 封装axios 函数文件 —&gt;传入三个参数</h5><p>单独封装这个函数文件的作用就是让不同的vue组件面对这个函数文件，然后这个函数文件依赖第三方框架axios，如果有一天axios这个框架不使用了只需要改变这个函数文件就可以了。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">#src 文件夹下新建network文件夹，下新建requeset.js</span><br><span class="line"><span class="keyword">import</span> axios <span class="keyword">from</span> <span class="string">&#x27;axios&#x27;</span></span><br><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">request</span>(<span class="params">config,success,failure</span>)</span>&#123;</span><br><span class="line">	<span class="comment">//创建实例对象</span></span><br><span class="line">	<span class="keyword">const</span> instance = axios.create(&#123;</span><br><span class="line">		baseURL = <span class="string">&#x27;http://123.207.32.32:8000&#x27;</span>,</span><br><span class="line">		timeout = <span class="number">5000</span></span><br><span class="line">	&#125;)</span><br><span class="line">	<span class="comment">//发送真正的网络请求</span></span><br><span class="line">	instance(config).then(<span class="function"><span class="params">res</span>=&gt;</span>&#123;</span><br><span class="line">		#这个地方不能对res 进行处理，因为这个地方只能请求到数据，具体的数据处理应该交给具体的页面组件中</span><br><span class="line">		#所以需要把res 这个数据回调出去</span><br><span class="line">		<span class="built_in">console</span>.log(res);</span><br><span class="line">		success(res)</span><br><span class="line">	&#125;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">#main.js页面</span><br><span class="line"><span class="keyword">import</span> &#123;request&#125; <span class="keyword">from</span> <span class="string">&#x27;.network/request&#x27;</span></span><br><span class="line">#传递了三个参数，分别是config,success,failure，通过函数回到res,err数据，进行处理。</span><br><span class="line">request(&#123;<span class="attr">url</span>:<span class="string">&#x27;/home/data&#x27;</span>&#125;,<span class="function"><span class="params">res</span>=&gt;</span>&#123;</span><br><span class="line"><span class="built_in">console</span>.log(res);&#125;,<span class="function"><span class="params">err</span>=&gt;</span>&#123;<span class="built_in">console</span>.log(err)&#125;)</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h5 id="13-6-封装axios函数文件-–-gt-传入一个参数"><a href="#13-6-封装axios函数文件-–-gt-传入一个参数" class="headerlink" title="13.6 封装axios函数文件 –&gt;传入一个参数"></a>13.6 封装axios函数文件 –&gt;传入一个参数</h5><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">#src 文件夹下新建network文件夹，下新建requeset.js</span><br><span class="line"><span class="keyword">import</span> axios <span class="keyword">from</span> <span class="string">&#x27;axios&#x27;</span></span><br><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">request</span>(<span class="params">config</span>)</span>&#123;</span><br><span class="line">	<span class="comment">//创建实例对象</span></span><br><span class="line">	<span class="keyword">const</span> instance = axios.create(&#123;</span><br><span class="line">		baseURL = <span class="string">&#x27;http://123.207.32.32:8000&#x27;</span>,</span><br><span class="line">		timeout = <span class="number">5000</span></span><br><span class="line">	&#125;)</span><br><span class="line">	<span class="comment">//发送真正的网络请求</span></span><br><span class="line">	<span class="comment">//从config中取出baseConfig</span></span><br><span class="line">	instance(config.baseConfig)</span><br><span class="line">		.then(<span class="function"><span class="params">res</span>=&gt;</span>&#123;</span><br><span class="line">		#这个地方不能对res 进行处理，因为这个地方只能请求到数据，具体的数据处理应该交给具体的页面组件中</span><br><span class="line">		#所以需要把res 这个数据回调出去</span><br><span class="line">		<span class="comment">//从config中取出success</span></span><br><span class="line">		config.success(res)</span><br><span class="line">	&#125;).catch(<span class="function"><span class="params">err</span>=&gt;</span>&#123;</span><br><span class="line">	<span class="comment">//从config中取出failure</span></span><br><span class="line">		config.failure(err)</span><br><span class="line">	&#125;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">#main.js页面</span><br><span class="line"><span class="keyword">import</span> &#123;request&#125; <span class="keyword">from</span> <span class="string">&#x27;.network/request&#x27;</span></span><br><span class="line">#传递了一个参数config，通过函数回到res,err数据，进行处理。</span><br><span class="line">config包含三个部分，分别是baseConfig、success、failure</span><br><span class="line">request(</span><br><span class="line">baseConfig:&#123;</span><br><span class="line"></span><br><span class="line">&#125;,</span><br><span class="line"><span class="attr">success</span>:<span class="function"><span class="keyword">function</span>(<span class="params">res</span>)</span>&#123;</span><br><span class="line">	</span><br><span class="line">&#125;</span><br><span class="line"><span class="attr">failure</span>:<span class="function"><span class="keyword">function</span>(<span class="params">err</span>)</span>&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h5 id="13-7-通过Promise的函数封装"><a href="#13-7-通过Promise的函数封装" class="headerlink" title="13.7 通过Promise的函数封装"></a>13.7 通过Promise的函数封装</h5><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">#src 文件夹下新建network文件夹，下新建requeset.js</span><br><span class="line"><span class="keyword">import</span> axios <span class="keyword">from</span> <span class="string">&#x27;axios&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">request</span>(<span class="params">config</span>)</span>&#123;</span><br><span class="line">	<span class="keyword">return</span> <span class="keyword">new</span> promise(<span class="function">(<span class="params">resolve,reject</span>)=&gt;</span>&#123;</span><br><span class="line">		<span class="comment">//1.创建axios实例</span></span><br><span class="line">		<span class="keyword">const</span> instance = axios.create(&#123;</span><br><span class="line">			baseURL = <span class="string">&#x27;http://123.207.32.32:8000&#x27;</span>,</span><br><span class="line">			<span class="attr">timeout</span>:<span class="number">5000</span></span><br><span class="line">		&#125;)</span><br><span class="line">		<span class="comment">//2.发送真正的网络请求</span></span><br><span class="line">		instance(config).then(<span class="function"><span class="params">res</span>=&gt;</span>&#123;</span><br><span class="line">			resolve(res)</span><br><span class="line">		&#125;).catch(<span class="function"><span class="params">err</span>=&gt;</span>&#123;</span><br><span class="line">			reject(err)</span><br><span class="line">		&#125;)</span><br><span class="line">	&#125;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">#main.js页面</span><br><span class="line"><span class="keyword">import</span> &#123;request&#125; <span class="keyword">from</span> <span class="string">&#x27;.network/request&#x27;</span></span><br><span class="line">request(&#123;</span><br><span class="line">	<span class="attr">url</span>:<span class="string">&#x27;/home/multidata&#x27;</span></span><br><span class="line">&#125;).then(<span class="function"><span class="params">res</span>=&gt;</span>&#123;</span><br><span class="line">	<span class="built_in">console</span>.log(res)</span><br><span class="line">&#125;).catch(<span class="function"><span class="params">err</span>=&gt;</span>&#123;</span><br><span class="line">	<span class="built_in">console</span>.log(err)</span><br><span class="line">&#125;)</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h5 id="13-8-最终版封装axios函数"><a href="#13-8-最终版封装axios函数" class="headerlink" title="13.8 最终版封装axios函数"></a>13.8 最终版封装axios函数</h5><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">#src 文件夹下新建network文件夹，下新建requeset.js</span><br><span class="line"><span class="keyword">import</span> axios <span class="keyword">from</span> <span class="string">&#x27;axios&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">request</span>(<span class="params">config</span>)</span>&#123;</span><br><span class="line">		<span class="comment">//1.创建axios实例</span></span><br><span class="line">		<span class="keyword">const</span> instance = axios.create(&#123;</span><br><span class="line">			<span class="attr">baseURL</span> : <span class="string">&#x27;http://123.207.32.32:8000&#x27;</span>,</span><br><span class="line">			<span class="attr">timeout</span>:<span class="number">5000</span></span><br><span class="line">		&#125;)</span><br><span class="line">		<span class="comment">//2.发送真正的网络请求</span></span><br><span class="line">		<span class="comment">//因为instance 这个方法在axios的源码中最终调用是会变成instancePromise的函数，所以最后我们直接返回这个函数就行。</span></span><br><span class="line">		<span class="keyword">return</span> instance(config)</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h5 id="13-9-axios-拦截器的作用"><a href="#13-9-axios-拦截器的作用" class="headerlink" title="13.9 axios 拦截器的作用"></a>13.9 axios 拦截器的作用</h5><ol>
<li>请求拦截的作用</li>
</ol>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">#interceptors是拦截器的意思。</span><br><span class="line">#request需要上传两个参数，两个函数，一个是满足的函数，一个是不满足的函数</span><br><span class="line">instance.interceptors.request.use(</span><br><span class="line">    #第一个函数参数</span><br><span class="line">    config=&gt;&#123;</span><br><span class="line">	<span class="built_in">console</span>.log(config);</span><br><span class="line">	#拦截之后必须要返回，否则之后请求无法成功。</span><br><span class="line">	<span class="keyword">return</span> config</span><br><span class="line">	&#125;,</span><br><span class="line">    #第二个函数参数</span><br><span class="line">    err=&gt;&#123;</span><br><span class="line">	<span class="built_in">console</span>.log(err)</span><br><span class="line">&#125;)</span><br><span class="line"><span class="comment">//拦截器的使用场景：</span></span><br><span class="line"><span class="comment">//1.比如config中的一些信息不符合服务器的要求。</span></span><br><span class="line"><span class="comment">//2.比如每次发送网络请求时，都希望在页面中显示一个请求的图标。</span></span><br><span class="line"><span class="comment">//3.某些网络请求（比如登录token），必须携带一些特殊的信息。</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>​    2.响应拦截的作用</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">instance.interceptors.response.use(</span><br><span class="line">	<span class="function"><span class="params">res</span>=&gt;</span>&#123;</span><br><span class="line">		cocnsole.log(res);</span><br><span class="line">		#可以对res结果进行处理。</span><br><span class="line">		<span class="keyword">return</span> res.data</span><br><span class="line">	&#125;,</span><br><span class="line">	<span class="function"><span class="params">err</span>=&gt;</span>&#123;</span><br><span class="line">		<span class="built_in">console</span>.log(err);</span><br><span class="line">	&#125;</span><br><span class="line">)</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h4 id="14-项目开发"><a href="#14-项目开发" class="headerlink" title="14 项目开发"></a>14 项目开发</h4><h5 id="14-1-better-scroll-的使用"><a href="#14-1-better-scroll-的使用" class="headerlink" title="14.1 better-scroll 的使用"></a>14.1 better-scroll 的使用</h5><p>​    better-scroll  因为第三方的安装包，所以一定要新建一个vue文件进行封装，然后谁使用它，谁就单独面对这个文件就行了。</p>
<ol>
<li><p>首先安装better-scroll</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">npm isntall better-scroll --save</span><br><span class="line"></span><br></pre></td></tr></table></figure></li>
<li><p>better-scroll的结构</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">&lt;div <span class="class"><span class="keyword">class</span></span>=<span class="string">&quot;wrapper&quot;</span>&gt;</span><br><span class="line">	<span class="xml"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;content&quot;</span>&gt;</span></span></span><br><span class="line"><span class="xml">		...</span></span><br><span class="line"><span class="xml">	<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">&lt;/div&gt;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p><strong>然后给wrapper这个div一个高度。</strong></p>
</li>
<li><p>导入better-scroll</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> BScroll <span class="keyword">from</span> <span class="string">&quot;better-scroll&quot;</span></span><br><span class="line"></span><br></pre></td></tr></table></figure></li>
<li><p>创建实例对象</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> bscroll = <span class="keyword">new</span> BScroll(.wrapper,&#123;</span><br><span class="line">	<span class="comment">//用来侦测是否对滚动金西行侦测，默认不侦测数值是0,1也是不侦测，2是侦测。但是只侦测手指拖动时的滚动，手指离开时的惯性滚动不侦测。3是只要是滚动都侦测。</span></span><br><span class="line">	<span class="attr">probeType</span>:<span class="number">0</span>,</span><br><span class="line">    <span class="comment">//阻止原生的时间，默认是false</span></span><br><span class="line">    <span class="attr">click</span>:<span class="literal">true</span>,</span><br><span class="line">     <span class="comment">//阻止上来加载更多。默认是false</span></span><br><span class="line">    <span class="attr">pullUpLoad</span>:<span class="literal">true</span></span><br><span class="line">&#125;)</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<ol>
<li><p>如果要使用上拉加载更多，首先得pullUpLoad:true</p>
</li>
<li><p>然后必须监听pullingUp事件</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">bscroll.on(<span class="string">&#x27;pullingUp&#x27;</span>,<span class="function">()=&gt;</span>&#123;</span><br><span class="line">	<span class="built_in">console</span>.log(<span class="string">&#x27;上拉加载更多&#x27;</span>);</span><br><span class="line">	<span class="comment">//发送网络请求，加载更多数据</span></span><br><span class="line">	<span class="comment">//但是pullingUp只能加载一次，要加载一下次，必须添加，finishPullUp</span></span><br><span class="line">	bscroll.finishPullUp()</span><br><span class="line">&#125;)</span><br><span class="line"></span><br></pre></td></tr></table></figure></li>
</ol>
</li>
<li><p>监听实时位置</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">//使用事件scroll</span></span><br><span class="line">bscroll.on(<span class="string">&#x27;scroll&#x27;</span>,<span class="function"><span class="params">position</span>=&gt;</span>&#123;</span><br><span class="line">	<span class="built_in">console</span>.log(position)</span><br><span class="line">&#125;)</span><br><span class="line"></span><br></pre></td></tr></table></figure></li>
</ol>
<h5 id="14-2-refs"><a href="#14-2-refs" class="headerlink" title="14.2 refs"></a>14.2 refs</h5><p>this.$refs.aaa  拿到的是组件对象 aaa 是在组件里面</p>
<p>this.$refs.bbb 拿到的是元素对象 bbb是在元素里面    </p>
<h5 id="14-3-无法滚动的bug处理"><a href="#14-3-无法滚动的bug处理" class="headerlink" title="14.3  无法滚动的bug处理"></a>14.3  无法滚动的bug处理</h5><ul>
<li><p>无法滚动的原因是图片是异步加载，而scroll 判断高度的时候图片还没有加载出来所以可滚动的高度是100+，但是等图片加载出来是，不会重新计算高度，导致无法向下滚动。</p>
</li>
<li><p>解决方法就是对goods-item组件里面的图片进行监听，当有一张图片完成加载就执行一次refresh。重新计算高度。</p>
</li>
<li><p>因为goods-item是home组件下的孙组件，所以通信比较麻烦，建议使用vuex或者时间总线处理。</p>
<ul>
<li>vuex 是用来保存公共组件的状态</li>
<li>事件组件是用来保存组件事件的。</li>
</ul>
</li>
<li><p>使用事件总线</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">//首先正在main.js中建立事件总线</span></span><br><span class="line">Vue.prototyep.$bus = <span class="keyword">new</span> Vue()</span><br><span class="line"><span class="comment">//然后在goods-item.vue组件里面监听图片加载</span></span><br><span class="line"><span class="function"><span class="title">imgLoad</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">	<span class="built_in">this</span>.$bus.$emit(<span class="string">&#x27;itemImgLoad&#x27;</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//然后在home.vue组件里监听,在DOM挂载完成后</span></span><br><span class="line"><span class="function"><span class="title">mounted</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">	<span class="built_in">this</span>.$bus.on(<span class="string">&#x27;ItemImgLoad&#x27;</span>,<span class="function">()=&gt;</span>&#123;</span><br><span class="line">		<span class="comment">//调用scroll组件里面的refresh方法</span></span><br><span class="line">		<span class="built_in">this</span>.$refs.scroll.refresh()</span><br><span class="line">	&#125;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure></li>
</ul>
<h5 id="14-4-防抖函数的使用"><a href="#14-4-防抖函数的使用" class="headerlink" title="14.4 防抖函数的使用"></a>14.4 防抖函数的使用</h5><ul>
<li><p>当解决页面卡顿使用refresh时，就要检测图片的加载，当有一个图片加载就refresh一次，每一次刷新页面就要请求服务器，所以这种方式，对服务器压力比较大。</p>
</li>
<li><p>所以我们可以使用防抖函数，举个例子，我们可以控制时间，假设是1秒当在1秒的时间内，我们有多次刷新，这个时候就只会调用一次。</p>
</li>
<li><p>函数的封装</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">//调用debounch函数 refersh是debounch的函数返回值（也是一个函数）</span></span><br><span class="line"><span class="keyword">const</span> refresh = debounce(<span class="built_in">this</span>.$refs.scroll.refresh,<span class="number">500</span>)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="title">mounted</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="built_in">this</span>.$bus.$on(<span class="string">&#x27;itemImgLoad&#x27;</span>,<span class="function">()=&gt;</span>&#123;</span><br><span class="line">        refresh()</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//对debounch函数的封装</span></span><br><span class="line"><span class="function"><span class="title">debounch</span>(<span class="params">func,delay</span>)</span>&#123;</span><br><span class="line">    <span class="comment">//这个let timer = null 一定要写在外面要不然下次就会被清除。</span></span><br><span class="line">    <span class="keyword">let</span> timer = <span class="literal">null</span></span><br><span class="line">    <span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params">...argus</span>)</span>&#123;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span>(timer) clearTimeOut(timer);</span><br><span class="line">        timer = setTimeOut(<span class="function">()=&gt;</span>&#123;</span><br><span class="line">            <span class="comment">//这里的func 相当于this.$refs.scroll.refresh</span></span><br><span class="line">            func.apply(<span class="built_in">this</span>,argus)</span><br><span class="line">        &#125;,delay)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure></li>
</ul>
<h5 id="14-5-保持home-首页的内容"><a href="#14-5-保持home-首页的内容" class="headerlink" title="14.5 保持home 首页的内容"></a>14.5 保持home 首页的内容</h5><ol>
<li><p>首先在app.js中使用keep-alive</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">&lt;keep-alive&gt;</span><br><span class="line">	<span class="xml"><span class="tag">&lt;<span class="name">router-view</span>/&gt;</span></span></span><br><span class="line">&lt;/keep-alive&gt;</span><br><span class="line"></span><br></pre></td></tr></table></figure></li>
<li><p>然后通过activate(){}生命周期函数跳转到保持的位置</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="title">activated</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">	<span class="built_in">this</span>.$refs.scroll.scrollTo(<span class="number">0</span>,<span class="built_in">this</span>.saveY,<span class="number">500</span>)</span><br><span class="line">    <span class="comment">//必须要刷新一下，不刷新可能导致页面无法滚动</span></span><br><span class="line">	<span class="built_in">this</span>.$refs.scroll.refresh()</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure></li>
<li><p>通过deactivated(){}生命周期函数获取当前位置的值</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="title">deactivated</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">	<span class="built_in">this</span>.saveY = <span class="built_in">this</span>.$refs.scroll.getSaveY()</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure></li>
<li><p>其中 saveY 是声明在data中的变量。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="title">data</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">	<span class="keyword">return</span> &#123;</span><br><span class="line">		<span class="attr">saveY</span>:<span class="number">0</span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure></li>
</ol>
<h5 id="14-6-正则表达式"><a href="#14-6-正则表达式" class="headerlink" title="14.6 正则表达式"></a>14.6 正则表达式</h5><ul>
<li>基本语法：<ul>
<li>+：表示匹配一个或者多个。</li>
<li>*：表示匹配0个或者多个。</li>
<li>？：表示匹配0个或者1个。</li>
<li>RegExp.$1:表示的是匹配到的第一个对象。</li>
</ul>
</li>
</ul>
<h5 id="14-7-类的继承"><a href="#14-7-类的继承" class="headerlink" title="14.7 类的继承"></a>14.7 类的继承</h5><ul>
<li><p>继承是发生在类的里面，可以减少重复的代码</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Animal</span> </span>&#123;</span><br><span class="line">	<span class="function"><span class="title">run</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">		<span class="built_in">console</span>.log(<span class="string">&#x27;这是一个run方法&#x27;</span>)</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//Person 这个类继承Animal的run方法</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span> <span class="keyword">extends</span> <span class="title">Animal</span> </span>&#123;</span><br><span class="line">	<span class="function"><span class="title">run</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">		<span class="built_in">console</span>.log(<span class="string">&#x27;这是一个run方法&#x27;</span>)</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure></li>
</ul>
<h5 id="14-8-两个组件之间共用相同的代码使用混入mixin"><a href="#14-8-两个组件之间共用相同的代码使用混入mixin" class="headerlink" title="14.8 两个组件之间共用相同的代码使用混入mixin"></a>14.8 两个组件之间共用相同的代码使用混入mixin</h5><p><strong>相同的内容：包括方法，mounted，components,data中的变量等都可以放到混入中</strong></p>
<p>使用的方法</p>
<ol>
<li><p>先在src /common目录下，新建mixin.js文件夹。</p>
</li>
<li><p>写入代码</p>
</li>
<li><p>```javascript<br>import {debounce from ‘./utils.js’}</p>
<p>export const itemListenerMixin = {</p>
<pre><code>mouted()&#123;
    let refresh =     debounce(this.$refs.scroll.refresh,500)
    //itemImgListener 是声明在home 和detail组件下的变量
    this.itemImgListener = ()=&gt;&#123;refresh()&#125;
    this.$bus.$on(&#39;itemImgLoad&#39;,this.itemImgListener)
&#125;
</code></pre>
<p>}</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">4. 在home和detail组件中导入</span><br><span class="line"></span><br><span class="line">```javascript</span><br><span class="line">import &#123;itemListenerMixin&#125; from &#x27;../../common/mixin.js&#x27;</span><br><span class="line"></span><br></pre></td></tr></table></figure></li>
</ol>
<p>​    5.在home和detail组件的option中加入mixins:[]</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span><br><span class="line">	<span class="attr">name</span>:<span class="string">&#x27;Home&#x27;</span>,</span><br><span class="line">	<span class="attr">mixins</span>:[ itemListenerMixin ]</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h5 id="14-9-联动效果–detail页面的导航栏"><a href="#14-9-联动效果–detail页面的导航栏" class="headerlink" title="14.9 联动效果–detail页面的导航栏"></a>14.9 联动效果–detail页面的导航栏</h5><ol>
<li><p>首先获取导航栏的index索引</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">detail 的导航栏组件</span><br><span class="line">&lt;div @click=<span class="string">&quot;changeNav(index)&quot;</span>&gt;&lt;/div&gt;</span><br><span class="line">methodes:&#123;</span><br><span class="line">	<span class="function"><span class="title">changeNav</span>(<span class="params">index</span>)</span>&#123;</span><br><span class="line">		<span class="built_in">this</span>.$emit(<span class="string">&#x27;changeNav&#x27;</span>,index)</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line">detail 的页面</span><br><span class="line">&lt;nav-item @changeNav=<span class="string">&quot;scrollPosition&quot;</span>&gt;&lt;/nav-item&gt;</span><br><span class="line"><span class="function"><span class="title">data</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">	<span class="keyword">return</span> &#123;</span><br><span class="line">		<span class="attr">scrollY</span>:[],</span><br><span class="line">		<span class="attr">getOffsetTop</span>:<span class="literal">null</span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;,</span><br><span class="line"><span class="function"><span class="title">created</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">	<span class="built_in">this</span>.getOffsetTop(<span class="function">()=&gt;</span>&#123;</span><br><span class="line">			<span class="built_in">this</span>.scrollY = []</span><br><span class="line">			<span class="built_in">this</span>.scrollY.push(<span class="built_in">this</span>.$refs.shangpin.$el.offsetTop)</span><br><span class="line">			<span class="built_in">this</span>.scrollY.push(<span class="built_in">this</span>.$refs.canshu.$el.offsetTop)</span><br><span class="line">			<span class="built_in">this</span>.scrollY.push(<span class="built_in">this</span>.$refs.pingjia.$el.offsetTop)</span><br><span class="line">			<span class="built_in">this</span>.scrollY.push(<span class="built_in">this</span>.$refs.tuijian.$el.offsetTop)</span><br><span class="line">		&#125;,<span class="number">50</span>)</span><br><span class="line">&#125;,</span><br><span class="line"><span class="attr">methods</span>:&#123;</span><br><span class="line">	<span class="function"><span class="title">scrollPosition</span>(<span class="params">index</span>)</span>&#123;</span><br><span class="line">		<span class="built_in">this</span>.$refs.scroll.scrollTo(<span class="number">0</span>,-<span class="built_in">this</span>.scrollY[index],<span class="number">100</span>)</span><br><span class="line">	&#125;,</span><br><span class="line">	<span class="function"><span class="title">detailImage</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">		<span class="built_in">this</span>.getOffsetTop()</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure></li>
</ol>
<h4 id="15-易错点分析"><a href="#15-易错点分析" class="headerlink" title="15. 易错点分析"></a>15. 易错点分析</h4><ol>
<li><p>for 循环的问题</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">//1.使用for in 循环打印出来的i 是字符串</span></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">let</span> i <span class="keyword">in</span> item)&#123;</span><br><span class="line"> 	<span class="built_in">console</span>.log(i) <span class="comment">//i是字符串。需要转换成数字格式</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//2.使用for 循环 打印出来的i是数字</span></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">let</span> i = <span class="number">0</span>;i&lt;item.length;i++)&#123;</span><br><span class="line">	<span class="built_in">console</span>.log(i)<span class="comment">//i是数字</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure></li>
</ol>
<h4 id="16-vux-的使用"><a href="#16-vux-的使用" class="headerlink" title="16.vux 的使用"></a>16.vux 的使用</h4><h4 id="17-toast-插件方式的封装"><a href="#17-toast-插件方式的封装" class="headerlink" title="17.toast 插件方式的封装"></a>17.toast 插件方式的封装</h4><ol>
<li><p>一种是普通方式的封装</p>
<ul>
<li>创建vue组件，Toast.vue</li>
<li>然后在每个页面中导入使用</li>
</ul>
</li>
<li><p>第二种是通过插件的方式封装组件</p>
<ul>
<li><p>在src文件夹下，新建toast文件夹，然后新建index.js文件和Toast.vue组件。</p>
</li>
<li><p>然后在main.js中导入</p>
</li>
<li><p>最后在index .js中创建组件构造器，和把组件挂载到div上</p>
</li>
<li><p>然后在toast.vue中添加具体的方法</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">this</span>.$toast.show()<span class="comment">//可以实现全局调用</span></span><br><span class="line"></span><br></pre></td></tr></table></figure></li>
</ul>
</li>
</ol>
<h4 id="18-fastclick-解决移动端点击延迟300ms的问题"><a href="#18-fastclick-解决移动端点击延迟300ms的问题" class="headerlink" title="18.fastclick 解决移动端点击延迟300ms的问题"></a>18.fastclick 解决移动端点击延迟300ms的问题</h4><h5 id="使用方法"><a href="#使用方法" class="headerlink" title="使用方法"></a>使用方法</h5><ol>
<li><p>安装fastclick</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">npm install fastclick --save</span><br><span class="line"></span><br></pre></td></tr></table></figure></li>
<li><p>导入fastclick</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> FastClick <span class="keyword">from</span> <span class="string">&#x27;fastclick&#x27;</span></span><br><span class="line"></span><br></pre></td></tr></table></figure></li>
<li><p>使用attach方法</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">FastClick.attch(<span class="built_in">document</span>.body);</span><br><span class="line"></span><br></pre></td></tr></table></figure></li>
</ol>
<h4 id="19-图片懒加载"><a href="#19-图片懒加载" class="headerlink" title="19.图片懒加载"></a>19.图片懒加载</h4><h5 id="使用步骤"><a href="#使用步骤" class="headerlink" title="使用步骤"></a>使用步骤</h5><ol>
<li><p>下载</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">npm install vue-lazyload --save</span><br><span class="line"></span><br></pre></td></tr></table></figure></li>
<li><p>导入</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> VueLazyLoad <span class="keyword">from</span> <span class="string">&#x27;vue-lazyload&#x27;</span></span><br><span class="line"></span><br></pre></td></tr></table></figure></li>
<li><p>使用</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">Vue.use(VueLazyLoad,&#123;</span><br><span class="line">	<span class="attr">loading</span>:<span class="built_in">require</span>(<span class="string">&#x27;....&#x27;</span>)</span><br><span class="line">	<span class="comment">//loading是用来自定义未加载出来图片时候的占位图</span></span><br><span class="line">&#125;)</span><br><span class="line"></span><br></pre></td></tr></table></figure></li>
<li><p>修改图片的路径</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">&lt;img :src=<span class="string">&quot;...&quot;</span>&gt;</span><br><span class="line"><span class="comment">//修改为</span></span><br><span class="line"><span class="xml"><span class="tag">&lt;<span class="name">img</span> <span class="attr">v-lazy</span>=<span class="string">&quot;...&quot;</span>&gt;</span></span></span><br><span class="line"><span class="xml"></span></span><br></pre></td></tr></table></figure></li>
</ol>
]]></content>
      <tags>
        <tag>vue</tag>
        <tag>javaScript</tag>
      </tags>
  </entry>
  <entry>
    <title>git 的熟练使用</title>
    <url>/2021/10/16/git-%E7%9A%84%E7%86%9F%E7%BB%83%E4%BD%BF%E7%94%A8/</url>
    <content><![CDATA[<h2 id="熟练掌握Git使用"><a href="#熟练掌握Git使用" class="headerlink" title="熟练掌握Git使用"></a>熟练掌握Git使用</h2><ol>
<li><p>基本的Linux命令学习</p>
<ul>
<li>cd :改变目录</li>
</ul>
</li>
</ol>
<ul>
<li><p>cd.. 回退到上一个目录，直接cd进入默认目录</p>
<ul>
<li>pwd:显示当前所在的目录路径</li>
</ul>
</li>
<li><p>ls(||):都是列出当前目录中的所有文件，只不过||列出的内容更为详细</p>
<ul>
<li>touch:新建一个文件，如touch index.js 就会在当前目录下新建一个index.js文件</li>
</ul>
 <span id="more"></span>

<ul>
<li><p>rm:删除一个文件 rm index.js 就会把当前文件夹下的index.js文件删除</p>
</li>
<li><p>mkdir:新建一个目录，就是新建一个文件夹</p>
</li>
<li><p>rm -r:删除一个文件夹，rm -r src 删除src目录</p>
</li>
<li><blockquote>
<p>rm -rf / :切勿在linux 中尝试，会删除电脑中的所有文件</p>
</blockquote>
</li>
<li><p>mv:移动文件，mv index.html src    index.html是我们要移动的文件，src是目标文件夹,当然这样使用必须保证要移动的文件和目标文件夹是在一个目录下。</p>
</li>
<li><p>reset： 重新初始化终端/清屏。</p>
</li>
<li><p>clear：清屏</p>
</li>
<li><p>history：查看命令历史</p>
</li>
<li><p>help：帮助</p>
</li>
<li><p>exit：退出</p>
</li>
<li><p>#：表示注释</p>
</li>
</ul>
</li>
</ul>
<h3 id="Git配置"><a href="#Git配置" class="headerlink" title="Git配置"></a>Git配置</h3><p>查看配置：git config -l</p>
<blockquote>
<p><strong>划重点</strong></p>
</blockquote>
<p>用户名和邮箱是一定要配置的，否则无法提交自己的代码 </p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">git config --global user.name &quot;light&quot; #名称</span><br><span class="line">git config --global user.email 1480418586@qq.com #邮箱</span><br></pre></td></tr></table></figure>

<h3 id="GIt基本理论（核心）"><a href="#GIt基本理论（核心）" class="headerlink" title="GIt基本理论（核心）"></a>GIt基本理论（核心）</h3><ul>
<li>git有四个工作区域，分别是，工作目录（Working Driectory),暂存区（stage/index),资源库（Repository或Git Directory）还有一个远程仓库(Remote Directory) ，文件在这四个区域之间的转换关系如下：</li>
<li><img src="C:\Users\吕晓亮\AppData\Roaming\Typora\typora-user-images\1629557163911.png" alt="1629557163911"></li>
<li>Workspace :工作区，就是你平时存放项目代码的地方</li>
<li>index/Stage:暂存区，用于临时存放你的改动，事实上他只是一个文件，保存即将提交到文件列表信息</li>
<li>Repository :仓库区（或本地仓库），就是安全存放数据的位置，这里面有你提交到所有版本的数据。其中HEAD指向最新放入仓库的版本。</li>
<li>Remote：远程仓库，托管代码的服务器</li>
</ul>
<h3 id="本地仓库搭建"><a href="#本地仓库搭建" class="headerlink" title="本地仓库搭建"></a>本地仓库搭建</h3><p>创建本地仓库的方法有两种，一种是创建全新的仓库，另一种是克隆远程仓库</p>
<ol>
<li><p>创建全新的仓库，需要用Git管理的项目的根目录执行：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#在当前目录新建一个Git代码库</span><br><span class="line">$ git init</span><br></pre></td></tr></table></figure></li>
<li><p>执行后可以看到，仅仅在项目目录下多出了一个.git目录，关于版本等所有信息都在这个目录下。</p>
<blockquote>
<p>克隆远程仓库</p>
</blockquote>
<ol>
<li><p>另一种方式是克隆远程目录，由于是将远程服务器上的仓库完全镜像一份至本地</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#克隆一个项目和他的整个代码历史（版本信息）</span><br><span class="line">$ git clone [url] https://github.io/....</span><br></pre></td></tr></table></figure></li>
</ol>
</li>
<li><p>查看文件状态</p>
</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#查看指定文件的状态</span><br><span class="line">git status [filename]</span><br><span class="line"></span><br><span class="line">#查看所有文件的状态</span><br><span class="line">git status</span><br><span class="line"></span><br><span class="line">#提交文件到暂存区</span><br><span class="line">git add</span><br><span class="line">git add .  表示提交所有文件到暂存区</span><br><span class="line"></span><br><span class="line">#提交暂存区中的内容到本地仓库</span><br><span class="line">git commit -m  其中-m表示的message，表示提交的信息</span><br></pre></td></tr></table></figure>

<p>4.忽略文件</p>
<p>有时候我们不想把某些文件纳入版本控制中，比如数据库文件，临时文件，设计文件等，在主目录下建立“.gitignore”文件，一般是自动生成，此文件有如下规则：</p>
<ul>
<li>忽略文件中的空行或以井号开始的行将会被忽略。</li>
<li>可以使用Linux通配符。例如星号代表任意多个字符，？号代表一个字符，方括号[abc]代表可选字符范围，大括号({string1,string2,….})代表可选的字符串等</li>
<li>如果名称的前面有一个感叹号！，表示例外规则，将不被忽略。</li>
<li>如果名称的最前面是一个路径分隔符/,表示要忽略的文件在此目录下，而子目录中的文件不可忽略。</li>
<li>如果名称的最后面是一个路径分隔符/，表示要忽略的文件是此目录该名称的子目录，而非文件（默认文件或目录都忽略）</li>
</ul>
<p>5.设置本机绑定SSH公钥，实现面密码登录，这一步很重要，GIthub是远程仓库，我们平时工作在本地仓库，当我们把数据从本地仓库push到远程仓库的需要密码，如果没有公钥，需要每次输入密码</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#进入 C:\Userss\Administrator\.ssh 目录下</span><br><span class="line">#生成公钥</span><br><span class="line">ssh-keygen -t -rsa</span><br><span class="line">#,会生成两个文件，一个ssh.rsa(私钥，不能泄露)，另一个ssh.rsa-pub(公钥)</span><br></pre></td></tr></table></figure>

<blockquote>
<p>git <strong>分支中常用命令</strong></p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#列出所有本地分支</span><br><span class="line">git branch</span><br><span class="line"></span><br><span class="line">#列出所有远程分支</span><br><span class="line">git branch -r </span><br><span class="line"></span><br><span class="line">#新建一个分支，但依然停留在当前分支</span><br><span class="line">git branch [branch-name]</span><br><span class="line"></span><br><span class="line">#新建一个分支，并切换到该分支</span><br><span class="line">git checkout -b [branch]</span><br><span class="line"></span><br><span class="line">#合并指定分支到当前分支</span><br><span class="line">git merge [branch]</span><br><span class="line"></span><br><span class="line">#删除分支</span><br><span class="line">git branch -d [branch-name]</span><br><span class="line"></span><br><span class="line">#删除远程分支</span><br><span class="line">git push origin --delete [branch-name]</span><br><span class="line">git branch -dr [remote/branch]</span><br></pre></td></tr></table></figure>

<p>多个分支如果并行执行，就会导致我们代码不冲突，也就是会同时存在多个版本</p>
<p><strong>eg</strong></p>
<p>现在有三组人在搞一个项目，分成三个部分</p>
<p>web-api  —&gt;A组负责</p>
<p>web-admin –&gt;B组负责 （B会调用A，修改了A的代码）</p>
<p>web-app –&gt;C组负责 （C会调用B和A的代码）</p>
<p>B和C组修改了A组的代码发生了冲突，这个时候需要协商，是保留哪一个</p>
<p><strong>如果同一个文件在合并分支时都被修改了则会引起冲突：解决的方法就是我们可以修改冲突文件后重新提交，选择要保留你的代码还是他的代码。</strong></p>
<p>master 主分支应该非常稳定，用来发布新版本，一般情况下不允许在上面工作，工作一般在新建的Dev分支上工作，工作完后，比如要发布，或者说dev分支代码稳定后可以合并到主分支master上了。</p>
]]></content>
      <tags>
        <tag>git</tag>
      </tags>
  </entry>
  <entry>
    <title>E6学习</title>
    <url>/2021/10/16/E6%E5%AD%A6%E4%B9%A0/</url>
    <content><![CDATA[<h3 id="ES6语法："><a href="#ES6语法：" class="headerlink" title="ES6语法："></a>ES6语法：</h3><h4 id="1-展开运算符（…）"><a href="#1-展开运算符（…）" class="headerlink" title="1.展开运算符（…）"></a>1.展开运算符（…）</h4><h5 id="1-1-数组展开"><a href="#1-1-数组展开" class="headerlink" title="1.1 数组展开"></a>1.1 数组展开</h5><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> arr = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>]</span><br><span class="line"><span class="keyword">let</span> arr2 = [<span class="string">&quot;a&quot;</span>,<span class="string">&quot;b&quot;</span>,<span class="string">&quot;c&quot;</span>,<span class="string">&quot;d&quot;</span>];</span><br><span class="line">#想要在arr2的b后面插入arr，使用ES6的方法</span><br><span class="line"> <span class="keyword">let</span> arr3 = [<span class="string">&quot;a&quot;</span>,<span class="string">&quot;b&quot;</span>,...arr,<span class="string">&quot;c&quot;</span>,<span class="string">&quot;d&quot;</span>]</span><br><span class="line"> #其中...就是展开运算符</span><br><span class="line"> <span class="built_in">console</span>.log(arr3)</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<span id="more"></span>

<ul>
<li><p>剩余对象：跟解构赋值搭配使用，取出剩余参数</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> arr = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>];</span><br><span class="line"># 剩余参数</span><br><span class="line"><span class="keyword">let</span> [a,b,...c] = arr;</span><br><span class="line">#...c相当于取出剩余部分</span><br><span class="line"><span class="built_in">console</span>.log(a,b,c) <span class="comment">// 1,2，[3,4]</span></span><br></pre></td></tr></table></figure></li>
</ul>
<h5 id="1-2-对象展开"><a href="#1-2-对象展开" class="headerlink" title="1.2 对象展开"></a>1.2 对象展开</h5><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> obj = &#123;</span><br><span class="line"><span class="attr">a</span>:<span class="number">1</span>,</span><br><span class="line"><span class="attr">b</span>:<span class="number">2</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> obj2 = &#123;</span><br><span class="line">...obj</span><br><span class="line"><span class="attr">c</span>:<span class="number">3</span></span><br><span class="line"><span class="attr">d</span>:<span class="number">4</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(obj2) <span class="comment">//&#123;a:1,b:2,c:3,d:4&#125;</span></span><br><span class="line">#同时对象之间进行赋值的时候会出现问题，</span><br><span class="line">#eg</span><br><span class="line"><span class="keyword">let</span> obj3 = obj</span><br><span class="line">obj3.a = <span class="number">10</span>;</span><br><span class="line"><span class="built_in">console</span>.log(obj) <span class="comment">//这时候obj中的a 值改为了10，如果我们不想obj里面的值发生变化，可以通过下面的方式</span></span><br><span class="line"><span class="keyword">let</span> obj3 = &#123;...obj&#125;;</span><br><span class="line">obj3.a = <span class="number">10</span>;</span><br><span class="line"><span class="built_in">console</span>.log(obj)<span class="comment">//不受影响</span></span><br></pre></td></tr></table></figure>





<h4 id="2-解构赋值"><a href="#2-解构赋值" class="headerlink" title="2.解构赋值"></a>2.解构赋值</h4><p>分为对象解构赋值</p>
<p>数组解构赋值</p>
<p>字符串解构赋值</p>
<ul>
<li><p>对象解构赋值</p>
<p>let obj = {‘a’ = 1,’b’= 2}</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">#在ES5中，要取到a和b的值肯定是通过 </span><br><span class="line"><span class="keyword">let</span> a = obj.a</span><br><span class="line"><span class="keyword">let</span> b = obj.b</span><br><span class="line">#但是在ES6中可以通过解构赋值的方式,其中a,b值跟对象中的值一一对应。</span><br><span class="line"><span class="keyword">let</span> &#123;a,b&#125; = obj </span><br><span class="line"><span class="built_in">console</span>.log(a,b)</span><br></pre></td></tr></table></figure></li>
<li><p>数组解构赋值</p>
<p>let arr = [“a”,”b”,”c”];</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">ES6 解构赋值</span><br><span class="line">let [e,f] = arr;</span><br><span class="line">console.log(e,f) //e,f分别取到数组中的a和b</span><br></pre></td></tr></table></figure>

<p>涉及到一道面试题</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> a = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">let</span> b = <span class="number">1</span>;</span><br><span class="line">#如何快速交换 a 和 b 的值</span><br><span class="line">#普通方式肯定就是增加一个变量来交换值</span><br><span class="line">#ES6解构赋值方式更为方便</span><br><span class="line">[a,b] = [b,a]</span><br></pre></td></tr></table></figure></li>
<li><p>字符串解构赋值</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">#第一种情况就是str是字符串</span><br><span class="line"><span class="keyword">let</span> str = <span class="string">&quot;abc&quot;</span>;</span><br><span class="line"><span class="keyword">let</span> [e,f] = str;</span><br><span class="line"><span class="built_in">console</span>.log(e,f) <span class="comment">//结果就是a和b</span></span><br><span class="line">#第二种情况就是nub 是数字型字符串</span><br><span class="line"><span class="keyword">let</span> nub = <span class="string">&#x27;123&#x27;</span>;</span><br><span class="line"><span class="keyword">let</span> [c,d] = nub</span><br><span class="line"><span class="built_in">console</span>.log(c,d)<span class="comment">//TypeError:nub is not iterable(迭代器)</span></span><br></pre></td></tr></table></figure></li>
</ul>
<h4 id="3-构造函数"><a href="#3-构造函数" class="headerlink" title="3.构造函数"></a>3.构造函数</h4><h5 id="3-1-Set-arr"><a href="#3-1-Set-arr" class="headerlink" title="3.1    Set(arr)"></a>3.1    Set(arr)</h5><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">let arr = [2,1,2,3,1,&quot;a&quot;,4,4,5]</span><br><span class="line">let s = new Set(arr)</span><br></pre></td></tr></table></figure>

<p>​    Set()函数的一些方法：</p>
<ul>
<li><p>set.clear() //清空所有值，返回的是一个空数组</p>
</li>
<li><p>set.delete(val)  //删除某一项</p>
<p>参数：val  要删除的某一项</p>
<p>返回值： true|false  是否删除成功，（没有这个值才会出现删除不成功）</p>
</li>
<li><p>set.has(val) //是否包含某一项</p>
<p>参数： val要查找的值</p>
<p>返回值：true|false  是否包含这个值</p>
</li>
<li><p>set.add(val) //添加一项</p>
<p>参数： val要添加的对象</p>
<p>返回值 ：set对象本身</p>
</li>
</ul>
<h5 id="3-2-Map"><a href="#3-2-Map" class="headerlink" title="3.2 Map()"></a>3.2 Map()</h5><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">let arr = [</span><br><span class="line">	[“a&quot;,1],</span><br><span class="line">	[&quot;b&quot;,2],</span><br><span class="line">	[&quot;c&quot;,3]</span><br><span class="line">];</span><br><span class="line">let m = new Map(arr);</span><br><span class="line">m.clear(); //清空所有值</span><br><span class="line">console.log(m.delete(&quot;a&quot;));//删除某一项的值</span><br><span class="line">console.log(m.get(&quot;b&quot;));//得到某一项的值</span><br><span class="line">console.log(m.set(&quot;d&quot;,5))//设置某一项的值，也可以修改值</span><br></pre></td></tr></table></figure>



<h4 id="4-函数对象的扩展"><a href="#4-函数对象的扩展" class="headerlink" title="4.函数对象的扩展"></a>4.函数对象的扩展</h4><h5 id="4-1箭头函数"><a href="#4-1箭头函数" class="headerlink" title="4.1箭头函数"></a>4.1箭头函数</h5><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#箭头函数当有一个形参时，这个时候可以不带括号</span><br><span class="line">let fn = nub =&gt; nub*2</span><br><span class="line"></span><br><span class="line">#箭头函数有两个形参时，这个时候必须带括号</span><br><span class="line">let fn = (nub,nub2) =&gt; nub*nub2</span><br><span class="line"></span><br><span class="line">#当箭头函数没有形参时，这时候也需要带上括号</span><br><span class="line">let fn = () =&gt; console.log(111)</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<ul>
<li><p>箭头函数没有不定参，arguements</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">let fn = () =&gt; console.log(arguements) //undefined</span><br><span class="line"></span><br><span class="line">fn(1,2,3,4)  //  ----&gt;结论箭头函数没有arguments</span><br><span class="line"></span><br><span class="line">#可以通过展开运算符，来显示</span><br><span class="line">let fn = (...arg) =&gt; console.log(arg)</span><br><span class="line">fn(1,2,3,4) // 结果是：[1,2,3,4]</span><br><span class="line"></span><br></pre></td></tr></table></figure></li>
<li><p><strong>箭头函数的this指向问题</strong></p>
<p>箭头函数本身没有this，调用箭头函数的this时，指向的是其声明时，所在的作用域的this。</p>
</li>
</ul>
<h5 id="4-2-数组新增方法"><a href="#4-2-数组新增方法" class="headerlink" title="4.2 数组新增方法"></a>4.2 数组新增方法</h5><h6 id="4-21-Array-构造函数下的3个方法"><a href="#4-21-Array-构造函数下的3个方法" class="headerlink" title="4.21.Array 构造函数下的3个方法"></a>4.21.Array 构造函数下的3个方法</h6><p>​    不能用数组，会报错（<strong>arr.from</strong> –&gt;error）</p>
<ul>
<li><p>Array.from(类数组)：把一个类数组转换成真正的数组。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> lis = <span class="built_in">document</span>.querySelectorAll(<span class="string">&quot;#list li&quot;</span>);</span><br><span class="line"># 因为通过querySelectorAll()获取到的是类数组，即只有小标和长度length 但是不能调用数组的方法。</span><br><span class="line">lis = <span class="built_in">Array</span>.from(lis)<span class="comment">//这个时候LIS 才是真的数组，可以使用数组的方法。</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<ul>
<li><p>也可以通过另外一种方式实现对类数组的转换：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#通过展开运算符的方式</span><br><span class="line">lis = [...lis];</span><br><span class="line"></span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p>Array.of(element1,element2,element3…): 将参数转成一个数组，返回值是一个新的数组。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> arr = <span class="built_in">Array</span>.of(<span class="string">&#x27;2&#x27;</span>,<span class="string">&#x27;3&#x27;</span>,<span class="string">&#x27;4&#x27;</span>,<span class="string">&#x27;a&#x27;</span>)</span><br><span class="line"><span class="built_in">console</span>.log(arr) <span class="comment">//[2,3,4,a]</span></span><br><span class="line"></span><br></pre></td></tr></table></figure></li>
<li><p>Array.isArray(arr) :检测数据是否是数组</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">let lis = document.querySelectorAll(&quot;#list li&quot;);</span><br><span class="line">console.log(Array.isArray(lis)) //false</span><br><span class="line"></span><br></pre></td></tr></table></figure></li>
</ul>
<h6 id="4-22-array-数组下的3个方法"><a href="#4-22-array-数组下的3个方法" class="headerlink" title="4.22.array 数组下的3个方法"></a>4.22.array 数组下的3个方法</h6><p><strong>arr.find(callback)</strong>:查找数组中的参数，当满足条件是就返回值，退出。（找到一个就返回并退出）</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">let arr = [1,2,3,4];</span><br><span class="line">console.log(arr.find(item =&gt; item &gt;=3)) //3</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>**arr.findIndex():**查找数组中的参数，当满足条件时就返回值对应的索引值，并退出。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">let arr = [1,2,3,4];</span><br><span class="line">console.log(arr.findIndex(item =&gt; item &gt;=3)) //2</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>**arr.flat() :**扁平化多维数组</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#当时二维数组的时候</span><br><span class="line">let arr = [</span><br><span class="line">	[&quot;小明&quot;，&quot;18&quot;],</span><br><span class="line">	[&quot;小刚&quot;,&quot;18&quot;]</span><br><span class="line">]</span><br><span class="line">console.log(arr.flat())//[&quot;小明&quot;,&quot;18&quot;,&quot;小刚&quot;,&quot;18&quot;]</span><br><span class="line"></span><br><span class="line">#当时多维数组时，而且我们无法判断里面嵌套了多少层的时候，我们可以通过以下方法实现</span><br><span class="line">let arr1 = [</span><br><span class="line">	[&quot;小明&quot;，&quot;18&quot;],</span><br><span class="line">	[&quot;小刚&quot;,&quot;18&quot;],</span><br><span class="line">	[</span><br><span class="line">		[2,[3,4]],</span><br><span class="line">		[5,6],</span><br><span class="line">	]</span><br><span class="line">]</span><br><span class="line">#传入一个参数Infinaty就可以了</span><br><span class="line">console.log(arr1.flat(Infinaty))//全部转换出来</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>arr.flatMap(): 返回新数组元素，跟上面的flat深度值为1的方式相同。但是flatMap通常在合并成一种方法的效率稍微高一点。</p>
<p>参数值，是回调函数，可选参数是index，和被调用的array数组</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">let arr = [</span><br><span class="line">	[&quot;小明&quot;，&quot;18&quot;],</span><br><span class="line">	[&quot;小刚&quot;,&quot;18&quot;]</span><br><span class="line">]</span><br><span class="line">let newArr = arr.flatMap((item,index) =&gt;console.log(item,index));//[&quot;小明&quot;，&quot;18&quot;],0</span><br><span class="line">[&quot;小刚&quot;,&quot;18&quot;],1</span><br><span class="line">console.log(newArr) //[&quot;小明&quot;，&quot;18&quot;,&quot;小刚&quot;,&quot;18&quot;]</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<ul>
<li>当我们只想返回第一个值的时候，不想要第二个值。</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> newArray = arr.flatMap(<span class="function">(<span class="params">item</span>) =&gt;</span>&#123;</span><br><span class="line">	item = item.filter(<span class="function">(<span class="params">item,index</span>) =&gt;</span>&#123;</span><br><span class="line">	<span class="keyword">return</span> index == <span class="number">0</span>;</span><br><span class="line">	&#125;)</span><br><span class="line">	retrun item;</span><br><span class="line">&#125;)</span><br><span class="line"><span class="built_in">console</span>.log(newArray) <span class="comment">// [&quot;小明&quot;,&quot;小刚&quot;]</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>arr.fill():用一个固定值填充一个数组中从起始索引到终止索引的全部元素。不包括终止索引。</p>
<p>Array arr.fill(value [,start [ ,end ]])</p>
<p>参数：用来填充数组的值。</p>
<p>可选参数：</p>
<p>​    start：起始索引，默认值为0</p>
<p>​    end ：终止索引，默认值为arr.length</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#默认只有一个参数的时候</span><br><span class="line">let arr = [0,1,2,3];</span><br><span class="line">arr.fill(&#x27;a&#x27;);</span><br><span class="line">cosole.log(arr);//[&quot;a&quot;,&quot;a&quot;,&quot;a&quot;,&quot;a&quot;]</span><br><span class="line">#</span><br><span class="line">arr.fill(&#x27;a&#x27;,1,2)</span><br><span class="line">console.log(arr);//[0,&quot;a&quot;,&quot;a&quot;,3]</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p><strong>arr.include():</strong></p>
<p>Boolean arr.includes(valueToFind[, fromIndex ]) 判断数组中是否包含一个指定的值。</p>
<ul>
<li>参数：valueToFind 需要查找的值。</li>
<li>可选参数：从from处开始向后查找。(索引值)</li>
<li>返回值：true 代表数组中包含valueToFind, false代表数组中不包含valueToFind。</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">let arr = [&quot;a&quot;,&quot;b&quot;,&quot;c&quot;,&quot;d&quot;]</span><br><span class="line">console.log(arr.includes(&quot;d&quot;)) //true</span><br><span class="line"></span><br><span class="line">#当有两个参数时</span><br><span class="line">console.log(arr.includes(&quot;c&quot;,3))//false</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h5 id="4-3-字符串方法"><a href="#4-3-字符串方法" class="headerlink" title="4.3 字符串方法"></a>4.3 字符串方法</h5><p><strong>str.startsWidth</strong></p>
<p>Boolean  str.startsWidth(searchString [, position])  判断当前字符串是否以另外一个给定的子字符串开头。</p>
<ul>
<li>参数：searchString  要搜索的子字符串。</li>
<li>可选参数：position 在str中搜素 searchString的开始位置，默认值为0，也就是真正的字符串开头处。</li>
<li>返回值：如果传入的子字符串在搜索的字符串的开始则返回true，否则返回false。</li>
</ul>
<p><strong>str.endsWidth</strong></p>
<p>这个方法使用方法跟上面相同。</p>
<p><strong>repeat</strong></p>
<p>repeat 方法可以复制字符串</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">let str = &quot;a&quot;;</span><br><span class="line">#参数为复制的次数</span><br><span class="line">console.log(str.repeat(3)) // &quot;aaa&quot;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h6 id="4-31-模板字符串"><a href="#4-31-模板字符串" class="headerlink" title="4.31.模板字符串"></a>4.31.模板字符串</h6><p>基本使用：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> p = <span class="built_in">document</span>.querySelector(<span class="string">&#x27;p&#x27;</span>);</span><br><span class="line"><span class="keyword">let</span> name = <span class="string">&quot;小明&quot;</span>;</span><br><span class="line"><span class="keyword">let</span> age = <span class="string">&quot;18&quot;</span>;</span><br><span class="line"><span class="keyword">let</span> school = <span class="string">&quot;初中&quot;</span>;</span><br><span class="line"># 这是ES5的插入变量的一种写法，这种方式比较普通，而且不方便。</span><br><span class="line">p.innerHTML = <span class="string">&quot;今年&lt;strong&gt; &#x27;+name+&#x27;&lt;/strong&gt;就要&lt;strong&gt; &#x27;+age+&#x27;&lt;/strong&gt;岁了，终于升入了&lt;strong&gt;&#x27;+school+&#x27;&lt;strong&gt;了&quot;</span>;</span><br><span class="line">#ES6的写法,首先外面要使用分号，然后变量使用插值表达式$&#123;变量&#125;</span><br><span class="line">p.innerHTML = <span class="string">`今年&lt;strong&gt; <span class="subst">$&#123;name&#125;</span>&lt;/strong&gt;就要&lt;strong&gt; <span class="subst">$&#123;age&#125;</span>&lt;/strong&gt;岁了，终于升入了&lt;strong&gt;<span class="subst">$&#123;school&#125;</span>&lt;strong&gt;了`</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h5 id="4-4-对象方法"><a href="#4-4-对象方法" class="headerlink" title="4.4 对象方法"></a>4.4 对象方法</h5><ul>
<li><p>对象的简洁表示法</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> a = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">let</span> b = <span class="number">1</span>;</span><br><span class="line">#ES5对象写法：</span><br><span class="line"><span class="keyword">let</span> obj = &#123;</span><br><span class="line">	<span class="attr">a</span>:a,</span><br><span class="line">	<span class="attr">b</span>:b,</span><br><span class="line">	<span class="attr">c</span>:<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">	<span class="built_in">console</span>.log(a)</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line">#ES6写法：简洁表示法</span><br><span class="line"><span class="keyword">let</span> obj = &#123;</span><br><span class="line">	a,</span><br><span class="line">	b,</span><br><span class="line">	<span class="function"><span class="title">c</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">	<span class="built_in">console</span>.log(a)</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure></li>
<li><p>对象的属性名表达式：通过ES6可以给对象的属性名赋值</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> name = <span class="string">&quot;小明&quot;</span>;</span><br><span class="line"><span class="keyword">let</span> obj =&#123;</span><br><span class="line">	<span class="function"><span class="title">c</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">	<span class="built_in">console</span>.log(<span class="string">&quot;a&quot;</span>)</span><br><span class="line">	&#125;,</span><br><span class="line">	[name]:<span class="number">111</span>  <span class="comment">//这种方式相当于把&quot;小明&quot;的值给了name</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure></li>
<li><p>Object.assign </p>
<p>Object Object.assign(target,…sources) 将所有的可枚举属性的值从一个或多个源对象复制到目标对象。</p>
<ul>
<li>参数：target 目标对象</li>
<li>sources :源对象</li>
<li>返回值：目标对象。</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> obj = &#123;</span><br><span class="line">	<span class="attr">a</span>:<span class="number">1</span>,</span><br><span class="line">	<span class="attr">b</span>:<span class="number">2</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">let</span> obj2 = &#123;</span><br><span class="line">	#...obj  这是第一种方式合并两个对象</span><br><span class="line">	<span class="attr">c</span>:<span class="number">3</span>,</span><br><span class="line">	<span class="attr">d</span>:<span class="number">4</span></span><br><span class="line">&#125;;</span><br><span class="line">#合并obj 和obj2有两种方式，第一种就是使用展开运算符的方式(可以选择插入位置，好用)</span><br><span class="line"></span><br><span class="line">#第二种方式就是使用<span class="built_in">Object</span> 方法</span><br><span class="line">obj2 = <span class="built_in">Object</span>.assign(obj2,obj);</span><br><span class="line"><span class="built_in">console</span>.log(obj2) <span class="comment">//[a:1,b:2,c:3,d:4]</span></span><br><span class="line"></span><br></pre></td></tr></table></figure></li>
<li><p>Object.is</p>
<p>Boolean Object.is(value,value2) 判断两个值是否是相同的值。</p>
<ul>
<li><p>规则：</p>
<p>两个值都是undefined</p>
<p>两个值都是null</p>
<p>两个值都是true 或者都是false</p>
<p>两个值都是由相同个数的字符按照相同的顺序组成的字符串</p>
<p>两个值指向同一个对象</p>
<p>两个值都是数字并且</p>
<p>​    都是正零 +0</p>
<p>​    都是负零 -0</p>
<p>​    都是NaN</p>
</li>
</ul>
</li>
</ul>
<h5 id="4-5-babel-的使用"><a href="#4-5-babel-的使用" class="headerlink" title="4.5 babel 的使用"></a>4.5 babel 的使用</h5><p>主要的作用就是为了兼容IE浏览器，需要把ES6代码转换成ES5的代码，这时候就需要使用babel来进行转化。</p>
<p><strong>使用的方法</strong></p>
<ol>
<li><p>首先在引入babel.min.js文件</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;script src=&quot;babel.min.js&quot;&gt; &lt;/script&gt; </span><br><span class="line"></span><br></pre></td></tr></table></figure></li>
<li><p>在script标签中加入style样式</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;script style=&quot;text/babel&quot;&gt; &lt;/script&gt;</span><br><span class="line"></span><br></pre></td></tr></table></figure></li>
</ol>
<h5 id=""><a href="#" class="headerlink" title=""></a></h5>]]></content>
      <tags>
        <tag>ES6</tag>
      </tags>
  </entry>
  <entry>
    <title>网络基础学习</title>
    <url>/2021/10/16/%E7%BD%91%E7%BB%9C%E5%9F%BA%E7%A1%80%E5%AD%A6%E4%B9%A0/</url>
    <content><![CDATA[<blockquote>
<h2 id="互联网是如何工作的"><a href="#互联网是如何工作的" class="headerlink" title="互联网是如何工作的"></a>互联网是如何工作的</h2></blockquote>
<h4 id="一、TCP协议："><a href="#一、TCP协议：" class="headerlink" title="一、TCP协议："></a>一、TCP协议：</h4><p>分为四个部分，分别是应用层，传输控制层，网络层和链路层，四个层级</p>
<h6 id="1-应用层：-–-gt-数据"><a href="#1-应用层：-–-gt-数据" class="headerlink" title="1.应用层：  –&gt;数据"></a><strong>1.应用层</strong>：  –&gt;<u>数据</u></h6><p>提供特定于应用程序的协议。http（负责浏览器和网络服务器的协议）、ftp(负责文件传输的协议)、IMAP（负责电子邮件客户端检索邮件的协议）</p>
<span id="more"></span>

<h6 id="2-传输控制层：（也称为TCP层）–-gt-数据、源端口、目标端口"><a href="#2-传输控制层：（也称为TCP层）–-gt-数据、源端口、目标端口" class="headerlink" title="2.传输控制层：（也称为TCP层）–&gt;数据、源端口、目标端口"></a>2.传输控制层：（也称为TCP层）–&gt;数据、<u>源端口、目标端口</u></h6><p>2.1    发送数据包到计算机使用特定端口号的应用程序</p>
<p>2.2    TCP：<u>面向连接</u>的<u>可靠</u>字节流服务协议</p>
<p>​        因为TCP必须经过三次握手建立连接之后才能交换数据，每个收到的数据包都会向发送方发送ack确认，以保证发送成功</p>
<h6 id="3-网络层：–-gt-数据、源端口、目标端口、源ip、目标ip地址"><a href="#3-网络层：–-gt-数据、源端口、目标端口、源ip、目标ip地址" class="headerlink" title="3.网络层：–&gt; 数据、源端口、目标端口、源ip、目标ip地址"></a>3.网络层：–&gt; 数据、源端口、目标端口、<u>源ip、目标ip地址</u></h6><p>​    3.1    使用ip地址将数据包发送到特定的计算机</p>
<p>​        3.2    ip是不可靠的无连接协议</p>
<p>​        ip传送数据包，每个数据包是独立的，而且ip传递不处理顺序可能会造成乱序到达的情况。但是TCP会根据数据包的序列号进行排序重组</p>
<h6 id="4-链路层："><a href="#4-链路层：" class="headerlink" title="4.链路层："></a>4.链路层：</h6><p>将二进制数据包与网络信号相互之间转换 </p>
<h5 id="4-1-注意点"><a href="#4-1-注意点" class="headerlink" title="4.1    注意点"></a>4.1    注意点</h5><p>​        ip跟ip地址不同，ip代表的网络协议，而ip地址表示是一串数字</p>
<p>​        ip地址有两种标准：分别是<strong>IP4(Internet Protocol version 4)</strong> 和<strong>IP6(Internet protocol version 6)</strong></p>
<h6 id="IP4"><a href="#IP4" class="headerlink" title="IP4:"></a>IP4:</h6><p>采用的32位地址，即4字节，因此地址空间只有2的32次方</p>
<p>因为IP4的地址位置少，所以IP6应运而生</p>
<h6 id="IP6"><a href="#IP6" class="headerlink" title="IP6"></a>IP6</h6><p>采用的是128位地址，</p>
<h6 id="从我们当前的电脑访问哔哩哔哩网站的过程："><a href="#从我们当前的电脑访问哔哩哔哩网站的过程：" class="headerlink" title="从我们当前的电脑访问哔哩哔哩网站的过程："></a>从我们当前的电脑访问哔哩哔哩网站的过程：</h6><p>电脑通过调制解调器（modem）也就是我们常说的猫（将计算机的数字信号翻译成可沿普通电话线传送的模拟信号后，在公共电话网络进行传输）。公共电话网络通过连接<strong>Internet server provider</strong>（ISP）互联网服务提供商–&gt;也就是三大运营商来接入互联网–&gt;然后ISP会通过NSP（NSP视为ISP提供网络主干服务的公司，ISP可以从NSP那里批量购入带宽，为客户提供网络接入服务），NSP网络通过网络访问点NAP相连来交换数据包流量 ，每个NSP都必须连接到至少三个网络访问点</p>
<p><strong>既然互联网是如此的复杂，互联网是如何帮数据包找到一个正确的路线？把数据包送到目的地</strong></p>
<p>在互联网中有个特殊的计算器-路由器，路由器上有个路由表，记录了其子网络的所有IP地址，然而他并不知道上层网络所包含的IP地址，当数据包到达路由器，路由器检查路由表上是否有目的地的IP地址，如果有则直接发送给那个网络，否则就向上层发送数据在更高的层级中去寻找拥有改IP的路由器，如果依然没有找到，则再次将数据包向上路由，知道到达NSP主干网为止，连接到NSP骨干网的路由器，拥有最大的路由表，通过这张表可以将数据路由到正确的骨干网 ，然后他将开始向下传播，进入越来越小的网络，知道找到目的地址为止</p>
<p>当我们修改地址的时候，通过地址就不能找到我们的数据，所以这时候有了域名，<strong>那么问题来了，</strong></p>
<h6 id="浏览器是如何通过域名知道访问哪个IP地址呢？"><a href="#浏览器是如何通过域名知道访问哪个IP地址呢？" class="headerlink" title="浏览器是如何通过域名知道访问哪个IP地址呢？"></a><strong>浏览器是如何通过域名知道访问哪个IP地址呢？</strong></h6><p>这里就需要用到Domain Names Service (DNS)  是一个分布式数据库，上面记录了域名和IP地址的对应的关系</p>
<p>当我们在客户端请求数据的时候这时候我们的客户端会先向DNS发送请求，找到对应的IP地址然后拿到IP地址之后在去请求对应IP地址的服务器。</p>
<p>当我们的IP地址发生变化之后我们只需要修改DNS中域名和对应的IP地址，然后重新绑定就可以了。</p>
<p>数据是如何展示到浏览器上的？</p>
<h6 id="二、浏览器的工作原理"><a href="#二、浏览器的工作原理" class="headerlink" title="二、浏览器的工作原理"></a>二、浏览器的工作原理</h6><h6 id="1-进程和线程的概念"><a href="#1-进程和线程的概念" class="headerlink" title="1.进程和线程的概念"></a>1.进程和线程的概念</h6><p><strong>进程</strong>：</p>
<p>是操作系统进行资源分配和调度的基本单位，可以申请和拥有计算机资源，进程是程序的基本执行实体。</p>
<p><strong>线程</strong></p>
<p>是操作系统能够进行运算调度的最小单位，一个进程中可以并发多个线程，每条线程并行执行不同的任务。</p>
<h6 id="2-根据浏览器进程不同来拆解浏览器"><a href="#2-根据浏览器进程不同来拆解浏览器" class="headerlink" title="2.  根据浏览器进程不同来拆解浏览器:"></a>2.  根据浏览器进程不同来拆解浏览器:</h6><p> <strong>2.1.浏览器进程</strong>：</p>
<p>负责控制Chrome浏览器除标签页外的用户界面，包括地址栏，书签，后退和前进按钮，以及负责浏览器和其他进程协调工作 。</p>
<p><strong>2.2.网络进程</strong></p>
<p>负责发起接受网络请求</p>
<p><strong>2.3.GPU进程</strong></p>
<p>GPU进程负责整个浏览器的界面的渲染</p>
<p><strong>2.4.插件进程</strong></p>
<p>负责控制网站使用的所有插件，例如flash，不包括扩展市场里面安装的扩展</p>
<p><strong>2.5.渲染器进程</strong></p>
<p>渲染器进程用来控制显示tab标签内所有的内容，浏览器默认情况下会为每个标签页都创建一个进程</p>
<h6 id="3-Chrome-一共有四个进程："><a href="#3-Chrome-一共有四个进程：" class="headerlink" title="3.Chrome 一共有四个进程："></a>3.Chrome 一共有四个进程：</h6><ol>
<li><p>process-per-site-instance</p>
<p>访问不同站点和同一站点的不同页面都会创建新的进程</p>
<p>这个是最占用内存的，但是也是最安全的，当tab中的一个标签卡死时并不会影响其他的标签</p>
</li>
<li><p>process-per-site</p>
<p>表示使用同一站点使用同一进程</p>
</li>
<li><p>process-per-tab</p>
<p>tab里所有站点使用同一进程</p>
</li>
<li><p>single process</p>
<p>让浏览器引擎和渲染引擎共用同一进程 </p>
</li>
</ol>
<h6 id="4-浏览器渲染进程的过程"><a href="#4-浏览器渲染进程的过程" class="headerlink" title="4.浏览器渲染进程的过程"></a>4.浏览器渲染进程的过程</h6><ul>
<li>浏览器通过网络请求后获取HTML数据，通过TCP传给渲染器进程。</li>
<li>DOM–主线程将HTML解析结构DOM树</li>
<li>style–样式计算</li>
<li>layoutTree –DOM+Style 根据DOM树和样式生成layoutTree</li>
<li>paint –绘制 通过遍历layoutTree 生成绘制顺序表</li>
<li>layer –布局 然后根据主线程将layoutTree和绘制信息表传给合成器线程</li>
<li>合成器线程 –将得到的信息分图层分成更小的图块</li>
<li>栅格线程 –将更小的图块进行栅格化raster,返回给合成器线程draw quads图块信息，存储在GPU中</li>
<li>frame 合成器将栅格线程返回的图块合成帧交给浏览器进程</li>
<li>浏览器进程收到一帧的图像后传给GPU进行渲染。</li>
</ul>
<h6 id="5-重拍和重绘的概念"><a href="#5-重拍和重绘的概念" class="headerlink" title="5.重拍和重绘的概念"></a>5.重拍和重绘的概念</h6><h6 id="5-1重排"><a href="#5-1重排" class="headerlink" title="5.1重排"></a>5.1重排</h6><ul>
<li>当改变DOM的属性时，会重新进行样式的计算，会重新布局和绘制，会使用主线程。</li>
</ul>
<h6 id="5-2重绘"><a href="#5-2重绘" class="headerlink" title="5.2重绘"></a>5.2重绘</h6><p>当改变颜色时，只会发生样式的计算和绘制，不会占用主线程。</p>
<h6 id="5-3一些重要方法"><a href="#5-3一些重要方法" class="headerlink" title="5.3一些重要方法"></a>5.3一些重要方法</h6><p><strong>requestAnimationFrame()</strong></p>
<p>会将主线程的任务分散到每一帧的间隔，从而不影响动画的流程。</p>
<p><strong>Fiber()</strong></p>
<p>react利用浏览器的空闲时间做优化。</p>
<p><strong>Transform</strong></p>
<p>​    会直接运行合成器线程，所以不会使用主线程的渲染。</p>
<p>​    在移动端使用3d转化可以优化性能（如果设备有3d加速引擎GPU可以提高性能，2d转换是无法调用GPU，2d靠的是CPU）。</p>
]]></content>
      <tags>
        <tag>计算机基础</tag>
      </tags>
  </entry>
  <entry>
    <title>手写闭包</title>
    <url>/2021/10/28/%E6%89%8B%E5%86%99%E9%97%AD%E5%8C%85/</url>
    <content><![CDATA[<ul>
<li><p>请看下面这段代码同时打印输出结果</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; ++i) &#123;</span><br><span class="line">  <span class="built_in">setTimeout</span>(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(i + <span class="string">&quot; &quot;</span>);</span><br><span class="line">  &#125;, <span class="number">100</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//输出结果为 5 5 5 5 5&gt;</span></span><br></pre></td></tr></table></figure></li>
</ul>
<p>答案 ：不能正常输出结果。</p>
<p>原因是：js运行属于单线程，setTimeout注册的函数需要等到线程空出来才能执行，此时for循环已经结束，i值为5，又因为循环中setTimeout接收的参数通过闭包访问变量i，所以5个定时输出都是5。</p>
<span id="more"></span>

<ul>
<li><p>解决方法：</p>
<p>将setTimeout放在立即执行函数中，将i值作为参数传递给包裹的函数，创建新闭包。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="keyword">var</span> i=<span class="number">0</span>;i&lt;<span class="number">5</span>;i++)&#123;</span><br><span class="line">	(<span class="function"><span class="keyword">function</span>(<span class="params">i</span>)</span>&#123;</span><br><span class="line">		<span class="built_in">setTimeout</span>(<span class="function">()=&gt;</span>&#123;</span><br><span class="line">			<span class="built_in">console</span>.log(i + <span class="string">&quot;&quot;</span>);</span><br><span class="line">		&#125;,<span class="number">100</span>)</span><br><span class="line">	&#125;)(i);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//输出结果为： 0 1 2 3 4</span></span><br></pre></td></tr></table></figure></li>
<li><p>第二种方式</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">add</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> x = <span class="number">1</span>;</span><br><span class="line">  <span class="built_in">console</span>.log(++x);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">add(); <span class="comment">//执行输出2,</span></span><br><span class="line"></span><br><span class="line">add(); <span class="comment">//执行还是输出2,</span></span><br></pre></td></tr></table></figure></li>
</ul>
<p>怎样才能使每次执行有加 1 效果呢?使用闭包???</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">add</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> x = <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(++x);</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> num = add();</span><br><span class="line"></span><br><span class="line">num(); <span class="comment">//输出2,</span></span><br><span class="line"></span><br><span class="line">num(); <span class="comment">//输出3,</span></span><br><span class="line"></span><br><span class="line">num(); <span class="comment">//输出4,</span></span><br></pre></td></tr></table></figure>]]></content>
      <tags>
        <tag>面试</tag>
      </tags>
  </entry>
</search>
